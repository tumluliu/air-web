;(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

if (!L.mapbox) throw new Error("include mapbox.js before air.js");

L.air = require("./src/directions");
L.air.format = require("./src/format");
L.air.layer = require("./src/layer");
L.air.inputControl = require("./src/input_control");
L.air.errorsControl = require("./src/errors_control");
L.air.routesControl = require("./src/routes_control");
// L.air.instructionsControl = require('./src/instructions_control');
L.air.tracksControl = require("./src/tracks_control.js");

},{"./src/directions":7,"./src/errors_control":8,"./src/format":9,"./src/input_control":11,"./src/layer":12,"./src/routes_control":14,"./src/tracks_control.js":16}],2:[function(require,module,exports){
!function(){
  var d3 = {version: "3.4.1"}; // semver
var d3_arraySlice = [].slice,
    d3_array = function(list) { return d3_arraySlice.call(list); }; // conversion for NodeLists

var d3_document = document,
    d3_documentElement = d3_document.documentElement,
    d3_window = window;

// Redefine d3_array if the browser doesnâ€™t support slice-based conversion.
try {
  d3_array(d3_documentElement.childNodes)[0].nodeType;
} catch(e) {
  d3_array = function(list) {
    var i = list.length, array = new Array(i);
    while (i--) array[i] = list[i];
    return array;
  };
}
var d3_subclass = {}.__proto__?

// Until ECMAScript supports array subclassing, prototype injection works well.
function(object, prototype) {
  object.__proto__ = prototype;
}:

// And if your browser doesn't support __proto__, we'll use direct extension.
function(object, prototype) {
  for (var property in prototype) object[property] = prototype[property];
};

function d3_vendorSymbol(object, name) {
  if (name in object) return name;
  name = name.charAt(0).toUpperCase() + name.substring(1);
  for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
    var prefixName = d3_vendorPrefixes[i] + name;
    if (prefixName in object) return prefixName;
  }
}

var d3_vendorPrefixes = ["webkit", "ms", "moz", "Moz", "o", "O"];

function d3_selection(groups) {
  d3_subclass(groups, d3_selectionPrototype);
  return groups;
}

var d3_select = function(s, n) { return n.querySelector(s); },
    d3_selectAll = function(s, n) { return n.querySelectorAll(s); },
    d3_selectMatcher = d3_documentElement[d3_vendorSymbol(d3_documentElement, "matchesSelector")],
    d3_selectMatches = function(n, s) { return d3_selectMatcher.call(n, s); };

// Prefer Sizzle, if available.
if (typeof Sizzle === "function") {
  d3_select = function(s, n) { return Sizzle(s, n)[0] || null; };
  d3_selectAll = function(s, n) { return Sizzle.uniqueSort(Sizzle(s, n)); };
  d3_selectMatches = Sizzle.matchesSelector;
}

d3.selection = function() {
  return d3_selectionRoot;
};

var d3_selectionPrototype = d3.selection.prototype = [];


d3_selectionPrototype.select = function(selector) {
  var subgroups = [],
      subgroup,
      subnode,
      group,
      node;

  selector = d3_selection_selector(selector);

  for (var j = -1, m = this.length; ++j < m;) {
    subgroups.push(subgroup = []);
    subgroup.parentNode = (group = this[j]).parentNode;
    for (var i = -1, n = group.length; ++i < n;) {
      if (node = group[i]) {
        subgroup.push(subnode = selector.call(node, node.__data__, i, j));
        if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
      } else {
        subgroup.push(null);
      }
    }
  }

  return d3_selection(subgroups);
};

function d3_selection_selector(selector) {
  return typeof selector === "function" ? selector : function() {
    return d3_select(selector, this);
  };
}

d3_selectionPrototype.selectAll = function(selector) {
  var subgroups = [],
      subgroup,
      node;

  selector = d3_selection_selectorAll(selector);

  for (var j = -1, m = this.length; ++j < m;) {
    for (var group = this[j], i = -1, n = group.length; ++i < n;) {
      if (node = group[i]) {
        subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
        subgroup.parentNode = node;
      }
    }
  }

  return d3_selection(subgroups);
};

function d3_selection_selectorAll(selector) {
  return typeof selector === "function" ? selector : function() {
    return d3_selectAll(selector, this);
  };
}
var d3_nsPrefix = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: "http://www.w3.org/1999/xhtml",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

d3.ns = {
  prefix: d3_nsPrefix,
  qualify: function(name) {
    var i = name.indexOf(":"),
        prefix = name;
    if (i >= 0) {
      prefix = name.substring(0, i);
      name = name.substring(i + 1);
    }
    return d3_nsPrefix.hasOwnProperty(prefix)
        ? {space: d3_nsPrefix[prefix], local: name}
        : name;
  }
};

d3_selectionPrototype.attr = function(name, value) {
  if (arguments.length < 2) {

    // For attr(string), return the attribute value for the first node.
    if (typeof name === "string") {
      var node = this.node();
      name = d3.ns.qualify(name);
      return name.local
          ? node.getAttributeNS(name.space, name.local)
          : node.getAttribute(name);
    }

    // For attr(object), the object specifies the names and values of the
    // attributes to set or remove. The values may be functions that are
    // evaluated for each element.
    for (value in name) this.each(d3_selection_attr(value, name[value]));
    return this;
  }

  return this.each(d3_selection_attr(name, value));
};

function d3_selection_attr(name, value) {
  name = d3.ns.qualify(name);

  // For attr(string, null), remove the attribute with the specified name.
  function attrNull() {
    this.removeAttribute(name);
  }
  function attrNullNS() {
    this.removeAttributeNS(name.space, name.local);
  }

  // For attr(string, string), set the attribute with the specified name.
  function attrConstant() {
    this.setAttribute(name, value);
  }
  function attrConstantNS() {
    this.setAttributeNS(name.space, name.local, value);
  }

  // For attr(string, function), evaluate the function for each element, and set
  // or remove the attribute as appropriate.
  function attrFunction() {
    var x = value.apply(this, arguments);
    if (x == null) this.removeAttribute(name);
    else this.setAttribute(name, x);
  }
  function attrFunctionNS() {
    var x = value.apply(this, arguments);
    if (x == null) this.removeAttributeNS(name.space, name.local);
    else this.setAttributeNS(name.space, name.local, x);
  }

  return value == null
      ? (name.local ? attrNullNS : attrNull) : (typeof value === "function"
      ? (name.local ? attrFunctionNS : attrFunction)
      : (name.local ? attrConstantNS : attrConstant));
}
function d3_collapse(s) {
  return s.trim().replace(/\s+/g, " ");
}
d3.requote = function(s) {
  return s.replace(d3_requote_re, "\\$&");
};

var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

d3_selectionPrototype.classed = function(name, value) {
  if (arguments.length < 2) {

    // For classed(string), return true only if the first node has the specified
    // class or classes. Note that even if the browser supports DOMTokenList, it
    // probably doesn't support it on SVG elements (which can be animated).
    if (typeof name === "string") {
      var node = this.node(),
          n = (name = d3_selection_classes(name)).length,
          i = -1;
      if (value = node.classList) {
        while (++i < n) if (!value.contains(name[i])) return false;
      } else {
        value = node.getAttribute("class");
        while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
      }
      return true;
    }

    // For classed(object), the object specifies the names of classes to add or
    // remove. The values may be functions that are evaluated for each element.
    for (value in name) this.each(d3_selection_classed(value, name[value]));
    return this;
  }

  // Otherwise, both a name and a value are specified, and are handled as below.
  return this.each(d3_selection_classed(name, value));
};

function d3_selection_classedRe(name) {
  return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
}

function d3_selection_classes(name) {
  return name.trim().split(/^|\s+/);
}

// Multiple class names are allowed (e.g., "foo bar").
function d3_selection_classed(name, value) {
  name = d3_selection_classes(name).map(d3_selection_classedName);
  var n = name.length;

  function classedConstant() {
    var i = -1;
    while (++i < n) name[i](this, value);
  }

  // When the value is a function, the function is still evaluated only once per
  // element even if there are multiple class names.
  function classedFunction() {
    var i = -1, x = value.apply(this, arguments);
    while (++i < n) name[i](this, x);
  }

  return typeof value === "function"
      ? classedFunction
      : classedConstant;
}

function d3_selection_classedName(name) {
  var re = d3_selection_classedRe(name);
  return function(node, value) {
    if (c = node.classList) return value ? c.add(name) : c.remove(name);
    var c = node.getAttribute("class") || "";
    if (value) {
      re.lastIndex = 0;
      if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
    } else {
      node.setAttribute("class", d3_collapse(c.replace(re, " ")));
    }
  };
}

d3_selectionPrototype.style = function(name, value, priority) {
  var n = arguments.length;
  if (n < 3) {

    // For style(object) or style(object, string), the object specifies the
    // names and values of the attributes to set or remove. The values may be
    // functions that are evaluated for each element. The optional string
    // specifies the priority.
    if (typeof name !== "string") {
      if (n < 2) value = "";
      for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
      return this;
    }

    // For style(string), return the computed style value for the first node.
    if (n < 2) return d3_window.getComputedStyle(this.node(), null).getPropertyValue(name);

    // For style(string, string) or style(string, function), use the default
    // priority. The priority is ignored for style(string, null).
    priority = "";
  }

  // Otherwise, a name, value and priority are specified, and handled as below.
  return this.each(d3_selection_style(name, value, priority));
};

function d3_selection_style(name, value, priority) {

  // For style(name, null) or style(name, null, priority), remove the style
  // property with the specified name. The priority is ignored.
  function styleNull() {
    this.style.removeProperty(name);
  }

  // For style(name, string) or style(name, string, priority), set the style
  // property with the specified name, using the specified priority.
  function styleConstant() {
    this.style.setProperty(name, value, priority);
  }

  // For style(name, function) or style(name, function, priority), evaluate the
  // function for each element, and set or remove the style property as
  // appropriate. When setting, use the specified priority.
  function styleFunction() {
    var x = value.apply(this, arguments);
    if (x == null) this.style.removeProperty(name);
    else this.style.setProperty(name, x, priority);
  }

  return value == null
      ? styleNull : (typeof value === "function"
      ? styleFunction : styleConstant);
}

d3_selectionPrototype.property = function(name, value) {
  if (arguments.length < 2) {

    // For property(string), return the property value for the first node.
    if (typeof name === "string") return this.node()[name];

    // For property(object), the object specifies the names and values of the
    // properties to set or remove. The values may be functions that are
    // evaluated for each element.
    for (value in name) this.each(d3_selection_property(value, name[value]));
    return this;
  }

  // Otherwise, both a name and a value are specified, and are handled as below.
  return this.each(d3_selection_property(name, value));
};

function d3_selection_property(name, value) {

  // For property(name, null), remove the property with the specified name.
  function propertyNull() {
    delete this[name];
  }

  // For property(name, string), set the property with the specified name.
  function propertyConstant() {
    this[name] = value;
  }

  // For property(name, function), evaluate the function for each element, and
  // set or remove the property as appropriate.
  function propertyFunction() {
    var x = value.apply(this, arguments);
    if (x == null) delete this[name];
    else this[name] = x;
  }

  return value == null
      ? propertyNull : (typeof value === "function"
      ? propertyFunction : propertyConstant);
}

d3_selectionPrototype.text = function(value) {
  return arguments.length
      ? this.each(typeof value === "function"
      ? function() { var v = value.apply(this, arguments); this.textContent = v == null ? "" : v; } : value == null
      ? function() { this.textContent = ""; }
      : function() { this.textContent = value; })
      : this.node().textContent;
};

d3_selectionPrototype.html = function(value) {
  return arguments.length
      ? this.each(typeof value === "function"
      ? function() { var v = value.apply(this, arguments); this.innerHTML = v == null ? "" : v; } : value == null
      ? function() { this.innerHTML = ""; }
      : function() { this.innerHTML = value; })
      : this.node().innerHTML;
};

d3_selectionPrototype.append = function(name) {
  name = d3_selection_creator(name);
  return this.select(function() {
    return this.appendChild(name.apply(this, arguments));
  });
};

function d3_selection_creator(name) {
  return typeof name === "function" ? name
      : (name = d3.ns.qualify(name)).local ? function() { return this.ownerDocument.createElementNS(name.space, name.local); }
      : function() { return this.ownerDocument.createElementNS(this.namespaceURI, name); };
}

d3_selectionPrototype.insert = function(name, before) {
  name = d3_selection_creator(name);
  before = d3_selection_selector(before);
  return this.select(function() {
    return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
  });
};

// TODO remove(selector)?
// TODO remove(node)?
// TODO remove(function)?
d3_selectionPrototype.remove = function() {
  return this.each(function() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  });
};
function d3_class(ctor, properties) {
  try {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  } catch (e) {
    ctor.prototype = properties;
  }
}

d3.map = function(object) {
  var map = new d3_Map;
  if (object instanceof d3_Map) object.forEach(function(key, value) { map.set(key, value); });
  else for (var key in object) map.set(key, object[key]);
  return map;
};

function d3_Map() {}

d3_class(d3_Map, {
  has: d3_map_has,
  get: function(key) {
    return this[d3_map_prefix + key];
  },
  set: function(key, value) {
    return this[d3_map_prefix + key] = value;
  },
  remove: d3_map_remove,
  keys: d3_map_keys,
  values: function() {
    var values = [];
    this.forEach(function(key, value) { values.push(value); });
    return values;
  },
  entries: function() {
    var entries = [];
    this.forEach(function(key, value) { entries.push({key: key, value: value}); });
    return entries;
  },
  size: d3_map_size,
  empty: d3_map_empty,
  forEach: function(f) {
    for (var key in this) if (key.charCodeAt(0) === d3_map_prefixCode) f.call(this, key.substring(1), this[key]);
  }
});

var d3_map_prefix = "\0", // prevent collision with built-ins
    d3_map_prefixCode = d3_map_prefix.charCodeAt(0);

function d3_map_has(key) {
  return d3_map_prefix + key in this;
}

function d3_map_remove(key) {
  key = d3_map_prefix + key;
  return key in this && delete this[key];
}

function d3_map_keys() {
  var keys = [];
  this.forEach(function(key) { keys.push(key); });
  return keys;
}

function d3_map_size() {
  var size = 0;
  for (var key in this) if (key.charCodeAt(0) === d3_map_prefixCode) ++size;
  return size;
}

function d3_map_empty() {
  for (var key in this) if (key.charCodeAt(0) === d3_map_prefixCode) return false;
  return true;
}

d3_selectionPrototype.data = function(value, key) {
  var i = -1,
      n = this.length,
      group,
      node;

  // If no value is specified, return the first value.
  if (!arguments.length) {
    value = new Array(n = (group = this[0]).length);
    while (++i < n) {
      if (node = group[i]) {
        value[i] = node.__data__;
      }
    }
    return value;
  }

  function bind(group, groupData) {
    var i,
        n = group.length,
        m = groupData.length,
        n0 = Math.min(n, m),
        updateNodes = new Array(m),
        enterNodes = new Array(m),
        exitNodes = new Array(n),
        node,
        nodeData;

    if (key) {
      var nodeByKeyValue = new d3_Map,
          dataByKeyValue = new d3_Map,
          keyValues = [],
          keyValue;

      for (i = -1; ++i < n;) {
        keyValue = key.call(node = group[i], node.__data__, i);
        if (nodeByKeyValue.has(keyValue)) {
          exitNodes[i] = node; // duplicate selection key
        } else {
          nodeByKeyValue.set(keyValue, node);
        }
        keyValues.push(keyValue);
      }

      for (i = -1; ++i < m;) {
        keyValue = key.call(groupData, nodeData = groupData[i], i);
        if (node = nodeByKeyValue.get(keyValue)) {
          updateNodes[i] = node;
          node.__data__ = nodeData;
        } else if (!dataByKeyValue.has(keyValue)) { // no duplicate data key
          enterNodes[i] = d3_selection_dataNode(nodeData);
        }
        dataByKeyValue.set(keyValue, nodeData);
        nodeByKeyValue.remove(keyValue);
      }

      for (i = -1; ++i < n;) {
        if (nodeByKeyValue.has(keyValues[i])) {
          exitNodes[i] = group[i];
        }
      }
    } else {
      for (i = -1; ++i < n0;) {
        node = group[i];
        nodeData = groupData[i];
        if (node) {
          node.__data__ = nodeData;
          updateNodes[i] = node;
        } else {
          enterNodes[i] = d3_selection_dataNode(nodeData);
        }
      }
      for (; i < m; ++i) {
        enterNodes[i] = d3_selection_dataNode(groupData[i]);
      }
      for (; i < n; ++i) {
        exitNodes[i] = group[i];
      }
    }

    enterNodes.update
        = updateNodes;

    enterNodes.parentNode
        = updateNodes.parentNode
        = exitNodes.parentNode
        = group.parentNode;

    enter.push(enterNodes);
    update.push(updateNodes);
    exit.push(exitNodes);
  }

  var enter = d3_selection_enter([]),
      update = d3_selection([]),
      exit = d3_selection([]);

  if (typeof value === "function") {
    while (++i < n) {
      bind(group = this[i], value.call(group, group.parentNode.__data__, i));
    }
  } else {
    while (++i < n) {
      bind(group = this[i], value);
    }
  }

  update.enter = function() { return enter; };
  update.exit = function() { return exit; };
  return update;
};

function d3_selection_dataNode(data) {
  return {__data__: data};
}

d3_selectionPrototype.datum = function(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.property("__data__");
};

d3_selectionPrototype.filter = function(filter) {
  var subgroups = [],
      subgroup,
      group,
      node;

  if (typeof filter !== "function") filter = d3_selection_filter(filter);

  for (var j = 0, m = this.length; j < m; j++) {
    subgroups.push(subgroup = []);
    subgroup.parentNode = (group = this[j]).parentNode;
    for (var i = 0, n = group.length; i < n; i++) {
      if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
        subgroup.push(node);
      }
    }
  }

  return d3_selection(subgroups);
};

function d3_selection_filter(selector) {
  return function() {
    return d3_selectMatches(this, selector);
  };
}

d3_selectionPrototype.order = function() {
  for (var j = -1, m = this.length; ++j < m;) {
    for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
};
d3.ascending = function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
};

d3_selectionPrototype.sort = function(comparator) {
  comparator = d3_selection_sortComparator.apply(this, arguments);
  for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);
  return this.order();
};

function d3_selection_sortComparator(comparator) {
  if (!arguments.length) comparator = d3.ascending;
  return function(a, b) {
    return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
  };
}
function d3_noop() {}

d3.dispatch = function() {
  var dispatch = new d3_dispatch,
      i = -1,
      n = arguments.length;
  while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
  return dispatch;
};

function d3_dispatch() {}

d3_dispatch.prototype.on = function(type, listener) {
  var i = type.indexOf("."),
      name = "";

  // Extract optional namespace, e.g., "click.foo"
  if (i >= 0) {
    name = type.substring(i + 1);
    type = type.substring(0, i);
  }

  if (type) return arguments.length < 2
      ? this[type].on(name)
      : this[type].on(name, listener);

  if (arguments.length === 2) {
    if (listener == null) for (type in this) {
      if (this.hasOwnProperty(type)) this[type].on(name, null);
    }
    return this;
  }
};

function d3_dispatch_event(dispatch) {
  var listeners = [],
      listenerByName = new d3_Map;

  function event() {
    var z = listeners, // defensive reference
        i = -1,
        n = z.length,
        l;
    while (++i < n) if (l = z[i].on) l.apply(this, arguments);
    return dispatch;
  }

  event.on = function(name, listener) {
    var l = listenerByName.get(name),
        i;

    // return the current listener, if any
    if (arguments.length < 2) return l && l.on;

    // remove the old listener, if any (with copy-on-write)
    if (l) {
      l.on = null;
      listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
      listenerByName.remove(name);
    }

    // add the new listener, if any
    if (listener) listeners.push(listenerByName.set(name, {on: listener}));

    return dispatch;
  };

  return event;
}

d3.event = null;

function d3_eventPreventDefault() {
  d3.event.preventDefault();
}

function d3_eventSource() {
  var e = d3.event, s;
  while (s = e.sourceEvent) e = s;
  return e;
}

// Like d3.dispatch, but for custom events abstracting native UI events. These
// events have a target component (such as a brush), a target element (such as
// the svg:g element containing the brush) and the standard arguments `d` (the
// target element's data) and `i` (the selection index of the target element).
function d3_eventDispatch(target) {
  var dispatch = new d3_dispatch,
      i = 0,
      n = arguments.length;

  while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);

  // Creates a dispatch context for the specified `thiz` (typically, the target
  // DOM element that received the source event) and `argumentz` (typically, the
  // data `d` and index `i` of the target element). The returned function can be
  // used to dispatch an event to any registered listeners; the function takes a
  // single argument as input, being the event to dispatch. The event must have
  // a "type" attribute which corresponds to a type registered in the
  // constructor. This context will automatically populate the "sourceEvent" and
  // "target" attributes of the event, as well as setting the `d3.event` global
  // for the duration of the notification.
  dispatch.of = function(thiz, argumentz) {
    return function(e1) {
      try {
        var e0 =
        e1.sourceEvent = d3.event;
        e1.target = target;
        d3.event = e1;
        dispatch[e1.type].apply(thiz, argumentz);
      } finally {
        d3.event = e0;
      }
    };
  };

  return dispatch;
}

d3_selectionPrototype.on = function(type, listener, capture) {
  var n = arguments.length;
  if (n < 3) {

    // For on(object) or on(object, boolean), the object specifies the event
    // types and listeners to add or remove. The optional boolean specifies
    // whether the listener captures events.
    if (typeof type !== "string") {
      if (n < 2) listener = false;
      for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
      return this;
    }

    // For on(string), return the listener for the first node.
    if (n < 2) return (n = this.node()["__on" + type]) && n._;

    // For on(string, function), use the default capture.
    capture = false;
  }

  // Otherwise, a type, listener and capture are specified, and handled as below.
  return this.each(d3_selection_on(type, listener, capture));
};

function d3_selection_on(type, listener, capture) {
  var name = "__on" + type,
      i = type.indexOf("."),
      wrap = d3_selection_onListener;

  if (i > 0) type = type.substring(0, i);
  var filter = d3_selection_onFilters.get(type);
  if (filter) type = filter, wrap = d3_selection_onFilter;

  function onRemove() {
    var l = this[name];
    if (l) {
      this.removeEventListener(type, l, l.$);
      delete this[name];
    }
  }

  function onAdd() {
    var l = wrap(listener, d3_array(arguments));
    onRemove.call(this);
    this.addEventListener(type, this[name] = l, l.$ = capture);
    l._ = listener;
  }

  function removeAll() {
    var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"),
        match;
    for (var name in this) {
      if (match = name.match(re)) {
        var l = this[name];
        this.removeEventListener(match[1], l, l.$);
        delete this[name];
      }
    }
  }

  return i
      ? listener ? onAdd : onRemove
      : listener ? d3_noop : removeAll;
}

var d3_selection_onFilters = d3.map({
  mouseenter: "mouseover",
  mouseleave: "mouseout"
});

d3_selection_onFilters.forEach(function(k) {
  if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
});

function d3_selection_onListener(listener, argumentz) {
  return function(e) {
    var o = d3.event; // Events can be reentrant (e.g., focus).
    d3.event = e;
    argumentz[0] = this.__data__;
    try {
      listener.apply(this, argumentz);
    } finally {
      d3.event = o;
    }
  };
}

function d3_selection_onFilter(listener, argumentz) {
  var l = d3_selection_onListener(listener, argumentz);
  return function(e) {
    var target = this, related = e.relatedTarget;
    if (!related || (related !== target && !(related.compareDocumentPosition(target) & 8))) {
      l.call(target, e);
    }
  };
}

d3_selectionPrototype.each = function(callback) {
  return d3_selection_each(this, function(node, i, j) {
    callback.call(node, node.__data__, i, j);
  });
};

function d3_selection_each(groups, callback) {
  for (var j = 0, m = groups.length; j < m; j++) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
      if (node = group[i]) callback(node, i, j);
    }
  }
  return groups;
}

d3_selectionPrototype.call = function(callback) {
  var args = d3_array(arguments);
  callback.apply(args[0] = this, args);
  return this;
};

d3_selectionPrototype.empty = function() {
  return !this.node();
};

d3_selectionPrototype.node = function() {
  for (var j = 0, m = this.length; j < m; j++) {
    for (var group = this[j], i = 0, n = group.length; i < n; i++) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
};

d3_selectionPrototype.size = function() {
  var n = 0;
  this.each(function() { ++n; });
  return n;
};

function d3_selection_enter(selection) {
  d3_subclass(selection, d3_selection_enterPrototype);
  return selection;
}

var d3_selection_enterPrototype = [];

d3.selection.enter = d3_selection_enter;
d3.selection.enter.prototype = d3_selection_enterPrototype;

d3_selection_enterPrototype.append = d3_selectionPrototype.append;
d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
d3_selection_enterPrototype.node = d3_selectionPrototype.node;
d3_selection_enterPrototype.call = d3_selectionPrototype.call;
d3_selection_enterPrototype.size = d3_selectionPrototype.size;


d3_selection_enterPrototype.select = function(selector) {
  var subgroups = [],
      subgroup,
      subnode,
      upgroup,
      group,
      node;

  for (var j = -1, m = this.length; ++j < m;) {
    upgroup = (group = this[j]).update;
    subgroups.push(subgroup = []);
    subgroup.parentNode = group.parentNode;
    for (var i = -1, n = group.length; ++i < n;) {
      if (node = group[i]) {
        subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
        subnode.__data__ = node.__data__;
      } else {
        subgroup.push(null);
      }
    }
  }

  return d3_selection(subgroups);
};

d3_selection_enterPrototype.insert = function(name, before) {
  if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
  return d3_selectionPrototype.insert.call(this, name, before);
};

function d3_selection_enterInsertBefore(enter) {
  var i0, j0;
  return function(d, i, j) {
    var group = enter[j].update,
        n = group.length,
        node;
    if (j != j0) j0 = j, i0 = 0;
    if (i >= i0) i0 = i + 1;
    while (!(node = group[i0]) && ++i0 < n);
    return node;
  };
}

// import "../transition/transition";

d3_selectionPrototype.transition = function() {
  var id = d3_transitionInheritId || ++d3_transitionId,
      subgroups = [],
      subgroup,
      node,
      transition = d3_transitionInherit || {time: Date.now(), ease: d3_ease_cubicInOut, delay: 0, duration: 250};

  for (var j = -1, m = this.length; ++j < m;) {
    subgroups.push(subgroup = []);
    for (var group = this[j], i = -1, n = group.length; ++i < n;) {
      if (node = group[i]) d3_transitionNode(node, i, id, transition);
      subgroup.push(node);
    }
  }

  return d3_transition(subgroups, id);
};
// import "../transition/transition";

d3_selectionPrototype.interrupt = function() {
  return this.each(d3_selection_interrupt);
};

function d3_selection_interrupt() {
  var lock = this.__transition__;
  if (lock) ++lock.active;
}

// TODO fast singleton implementation?
d3.select = function(node) {
  var group = [typeof node === "string" ? d3_select(node, d3_document) : node];
  group.parentNode = d3_documentElement;
  return d3_selection([group]);
};

d3.selectAll = function(nodes) {
  var group = d3_array(typeof nodes === "string" ? d3_selectAll(nodes, d3_document) : nodes);
  group.parentNode = d3_documentElement;
  return d3_selection([group]);
};

var d3_selectionRoot = d3.select(d3_documentElement);
  if (typeof define === "function" && define.amd) {
    define(d3);
  } else if (typeof module === "object" && module.exports) {
    module.exports = d3;
  } else {
    this.d3 = d3;
  }
}();

},{}],3:[function(require,module,exports){
function corslite(url, callback, cors) {
    var sent = false;

    if (typeof window.XMLHttpRequest === 'undefined') {
        return callback(Error('Browser not supported'));
    }

    if (typeof cors === 'undefined') {
        var m = url.match(/^\s*https?:\/\/[^\/]*/);
        cors = m && (m[0] !== location.protocol + '//' + location.hostname +
                (location.port ? ':' + location.port : ''));
    }

    var x = new window.XMLHttpRequest();

    function isSuccessful(status) {
        return status >= 200 && status < 300 || status === 304;
    }

    if (cors && !('withCredentials' in x)) {
        // IE8-9
        x = new window.XDomainRequest();

        // Ensure callback is never called synchronously, i.e., before
        // x.send() returns (this has been observed in the wild).
        // See https://github.com/mapbox/mapbox.js/issues/472
        var original = callback;
        callback = function() {
            if (sent) {
                original.apply(this, arguments);
            } else {
                var that = this, args = arguments;
                setTimeout(function() {
                    original.apply(that, args);
                }, 0);
            }
        }
    }

    function loaded() {
        if (
            // XDomainRequest
            x.status === undefined ||
            // modern browsers
            isSuccessful(x.status)) callback.call(x, null, x);
        else callback.call(x, x, null);
    }

    // Both `onreadystatechange` and `onload` can fire. `onreadystatechange`
    // has [been supported for longer](http://stackoverflow.com/a/9181508/229001).
    if ('onload' in x) {
        x.onload = loaded;
    } else {
        x.onreadystatechange = function readystate() {
            if (x.readyState === 4) {
                loaded();
            }
        };
    }

    // Call the callback with the XMLHttpRequest object as an error and prevent
    // it from ever being called again by reassigning it to `noop`
    x.onerror = function error(evt) {
        // XDomainRequest provides no evt parameter
        callback.call(this, evt || true, null);
        callback = function() { };
    };

    // IE9 must have onprogress be set to a unique function.
    x.onprogress = function() { };

    x.ontimeout = function(evt) {
        callback.call(this, evt, null);
        callback = function() { };
    };

    x.onabort = function(evt) {
        callback.call(this, evt, null);
        callback = function() { };
    };

    // GET is the only supported HTTP Verb by XDomainRequest and is the
    // only one supported here.
    x.open('GET', url, true);

    // Send the request. Sending data is not supported.
    x.send(null);
    sent = true;

    return x;
}

if (typeof module !== 'undefined') module.exports = corslite;

},{}],4:[function(require,module,exports){
'use strict';

/**
 * Based off of [the offical Google document](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)
 *
 * Some parts from [this implementation](http://facstaff.unca.edu/mcmcclur/GoogleMaps/EncodePolyline/PolylineEncoder.js)
 * by [Mark McClure](http://facstaff.unca.edu/mcmcclur/)
 *
 * @module polyline
 */

var polyline = {};

function py2_round(value) {
    // Google's polyline algorithm uses the same rounding strategy as Python 2, which is different from JS for negative values
    return Math.floor(Math.abs(value) + 0.5) * Math.sign(value);
}

function encode(current, previous, factor) {
    current = py2_round(current * factor);
    previous = py2_round(previous * factor);
    var coordinate = current - previous;
    coordinate <<= 1;
    if (current - previous < 0) {
        coordinate = ~coordinate;
    }
    var output = '';
    while (coordinate >= 0x20) {
        output += String.fromCharCode((0x20 | (coordinate & 0x1f)) + 63);
        coordinate >>= 5;
    }
    output += String.fromCharCode(coordinate + 63);
    return output;
}

/**
 * Decodes to a [latitude, longitude] coordinates array.
 *
 * This is adapted from the implementation in Project-OSRM.
 *
 * @param {String} str
 * @param {Number} precision
 * @returns {Array}
 *
 * @see https://github.com/Project-OSRM/osrm-frontend/blob/master/WebContent/routing/OSRM.RoutingGeometry.js
 */
polyline.decode = function(str, precision) {
    var index = 0,
        lat = 0,
        lng = 0,
        coordinates = [],
        shift = 0,
        result = 0,
        byte = null,
        latitude_change,
        longitude_change,
        factor = Math.pow(10, precision || 5);

    // Coordinates have variable length when encoded, so just keep
    // track of whether we've hit the end of the string. In each
    // loop iteration, a single coordinate is decoded.
    while (index < str.length) {

        // Reset shift, result, and byte
        byte = null;
        shift = 0;
        result = 0;

        do {
            byte = str.charCodeAt(index++) - 63;
            result |= (byte & 0x1f) << shift;
            shift += 5;
        } while (byte >= 0x20);

        latitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));

        shift = result = 0;

        do {
            byte = str.charCodeAt(index++) - 63;
            result |= (byte & 0x1f) << shift;
            shift += 5;
        } while (byte >= 0x20);

        longitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));

        lat += latitude_change;
        lng += longitude_change;

        coordinates.push([lat / factor, lng / factor]);
    }

    return coordinates;
};

/**
 * Encodes the given [latitude, longitude] coordinates array.
 *
 * @param {Array.<Array.<Number>>} coordinates
 * @param {Number} precision
 * @returns {String}
 */
polyline.encode = function(coordinates, precision) {
    if (!coordinates.length) { return ''; }

    var factor = Math.pow(10, precision || 5),
        output = encode(coordinates[0][0], 0, factor) + encode(coordinates[0][1], 0, factor);

    for (var i = 1; i < coordinates.length; i++) {
        var a = coordinates[i], b = coordinates[i - 1];
        output += encode(a[0], b[0], factor);
        output += encode(a[1], b[1], factor);
    }

    return output;
};

function flipped(coords) {
    var flipped = [];
    for (var i = 0; i < coords.length; i++) {
        flipped.push(coords[i].slice().reverse());
    }
    return flipped;
}

/**
 * Encodes a GeoJSON LineString feature/geometry.
 *
 * @param {Object} geojson
 * @param {Number} precision
 * @returns {String}
 */
polyline.fromGeoJSON = function(geojson, precision) {
    if (geojson && geojson.type === 'Feature') {
        geojson = geojson.geometry;
    }
    if (!geojson || geojson.type !== 'LineString') {
        throw new Error('Input must be a GeoJSON LineString');
    }
    return polyline.encode(flipped(geojson.coordinates), precision);
};

/**
 * Decodes to a GeoJSON LineString geometry.
 *
 * @param {String} str
 * @param {Number} precision
 * @returns {Object}
 */
polyline.toGeoJSON = function(str, precision) {
    var coords = polyline.decode(str, precision);
    return {
        type: 'LineString',
        coordinates: flipped(coords)
    };
};

if (typeof module === 'object' && module.exports) {
    module.exports = polyline;
}

},{}],5:[function(require,module,exports){
/**
 * Returns a function, that, as long as it continues to be invoked, will not
 * be triggered. The function will be called after it stops being called for
 * N milliseconds. If `immediate` is passed, trigger the function on the
 * leading edge, instead of the trailing. The function also has a property 'clear' 
 * that is a function which will clear the timer to prevent previously scheduled executions. 
 *
 * @source underscore.js
 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
 * @param {Function} function to wrap
 * @param {Number} timeout in ms (`100`)
 * @param {Boolean} whether to execute at the beginning (`false`)
 * @api public
 */

module.exports = function debounce(func, wait, immediate){
  var timeout, args, context, timestamp, result;
  if (null == wait) wait = 100;

  function later() {
    var last = Date.now() - timestamp;

    if (last < wait && last >= 0) {
      timeout = setTimeout(later, wait - last);
    } else {
      timeout = null;
      if (!immediate) {
        result = func.apply(context, args);
        context = args = null;
      }
    }
  };

  var debounced = function(){
    context = this;
    args = arguments;
    timestamp = Date.now();
    var callNow = immediate && !timeout;
    if (!timeout) timeout = setTimeout(later, wait);
    if (callNow) {
      result = func.apply(context, args);
      context = args = null;
    }

    return result;
  };

  debounced.clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    }
  };

  return debounced;
};

},{}],6:[function(require,module,exports){
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define('queue', factory) :
  (global.queue = factory());
}(this, function () { 'use strict';

  var slice = [].slice;

  function noop() {}

  var noabort = {};
  var success = [null];
  function newQueue(concurrency) {
    if (!(concurrency >= 1)) throw new Error;

    var q,
        tasks = [],
        results = [],
        waiting = 0,
        active = 0,
        ended = 0,
        starting, // inside a synchronous task callback?
        error,
        callback = noop,
        callbackAll = true;

    function start() {
      if (starting) return; // let the current task complete
      while (starting = waiting && active < concurrency) {
        var i = ended + active,
            t = tasks[i],
            j = t.length - 1,
            c = t[j];
        t[j] = end(i);
        --waiting, ++active, tasks[i] = c.apply(null, t) || noabort;
      }
    }

    function end(i) {
      return function(e, r) {
        if (!tasks[i]) throw new Error; // detect multiple callbacks
        --active, ++ended, tasks[i] = null;
        if (error != null) return; // only report the first error
        if (e != null) {
          abort(e);
        } else {
          results[i] = r;
          if (waiting) start();
          else if (!active) notify();
        }
      };
    }

    function abort(e) {
      error = e; // ignore new tasks and squelch active callbacks
      waiting = NaN; // stop queued tasks from starting
      notify();
    }

    function notify() {
      if (error != null) callback(error);
      else if (callbackAll) callback(null, results);
      else callback.apply(null, success.concat(results));
    }

    return q = {
      defer: function(f) {
        if (callback !== noop) throw new Error;
        var t = slice.call(arguments, 1);
        t.push(f);
        ++waiting, tasks.push(t);
        start();
        return q;
      },
      abort: function() {
        if (error == null) {
          var i = ended + active, t;
          while (--i >= 0) (t = tasks[i]) && t.abort && t.abort();
          abort(new Error("abort"));
        }
        return q;
      },
      await: function(f) {
        if (callback !== noop) throw new Error;
        callback = f, callbackAll = false;
        if (!waiting && !active) notify();
        return q;
      },
      awaitAll: function(f) {
        if (callback !== noop) throw new Error;
        callback = f, callbackAll = true;
        if (!waiting && !active) notify();
        return q;
      }
    };
  }

  function queue(concurrency) {
    return newQueue(arguments.length ? +concurrency : Infinity);
  }

  queue.version = "1.2.1";

  return queue;

}));
},{}],7:[function(require,module,exports){
"use strict";

var getRequest = require("./get_request"),
    polyline = require("@mapbox/polyline"),
    queue = require("queue-async");

var Directions = L.Class.extend({
    includes: [L.Mixin.Events],

    options: {
        available_providers: ["mapbox", "google", "openrouteservice"],
        enabled_providers: [],
        unit: "meters",
        mapbox: {
            api_template:
                "https://api.mapbox.com/directions/v5/mapbox/cycling/{waypoints}?geometries=polyline&access_token={token}",
            geocoder_template:
                "https://api.tiles.mapbox.com/v4/geocode/mapbox.places/{query}.json?proximity={proximity}&access_token={token}",
            key:
                "pk.eyJ1IjoibGxpdSIsImEiOiI4dW5uVkVJIn0.jhfpLn2Esk_6ZSG62yXYOg",
            profile: "cycling",
            path_style: {
                stroke: "#4264fb",
                "stroke-opacity": 0.78,
                "stroke-width": 5
            }
        },
        openrouteservice: {
            api_template:
                "https://api.openrouteservice.org/corsdirections?&coordinates={coordinates}&instructions=false&preference={preference}&profile={profile}&api_key={token}",
            key: "58d904a497c67e00015b45fcf243eacf4b25434c6e28d7fd61c9d309",
            preference: "",
            profile: "cycling-regular",
            path_style: {
                stroke: "#cf5f5f",
                "stroke-opacity": 0.78,
                "stroke-width": 5
            }
        },
        google: {
            api_template:
                "https://luliu.me/gmapswrapper?origin={origin}&destination={destination}&mode=bicycling&key={token}",
            key: "AIzaSyDc2gadWI4nunYb0i5Mx_P3AH_yDTiMzAY",
            profile: "bicycling",
            path_style: {
                stroke: "#0f9d58",
                "stroke-opacity": 0.78,
                "stroke-width": 5
            }
        }
    },

    directions: {
        routes: {
            type: "FeatureCollection",
            features: []
        }
    },

    initialize: function(options) {
        L.setOptions(this, options);
        this._waypoints = [];
    },

    getOrigin: function() {
        return this.origin;
    },

    getDestination: function() {
        return this.destination;
    },

    setOrigin: function(origin) {
        origin = this._normalizeWaypoint(origin);

        this.origin = origin;
        this.fire("origin", {
            origin: origin
        });

        if (!origin) {
            this._unload();
        }

        return this;
    },

    setDestination: function(destination) {
        destination = this._normalizeWaypoint(destination);

        this.destination = destination;
        this.fire("destination", {
            destination: destination
        });

        if (!destination) {
            this._unload();
        }

        return this;
    },

    getWaypoints: function() {
        return this._waypoints;
    },

    setWaypoints: function(waypoints) {
        this._waypoints = waypoints.map(this._normalizeWaypoint);
        return this;
    },

    addWaypoint: function(index, waypoint) {
        this._waypoints.splice(index, 0, this._normalizeWaypoint(waypoint));
        return this;
    },

    removeWaypoint: function(index) {
        this._waypoints.splice(index, 1);
        return this;
    },

    setWaypoint: function(index, waypoint) {
        this._waypoints[index] = this._normalizeWaypoint(waypoint);
        return this;
    },

    reverse: function() {
        var o = this.origin,
            d = this.destination;

        this.origin = d;
        this.destination = o;
        this._waypoints.reverse();

        this.fire("origin", {
            origin: this.origin
        }).fire("destination", {
            destination: this.destination
        });

        return this;
    },

    selectRoute: function(route) {
        this.fire("selectRoute", {
            route: route
        });
    },

    selectTrack: function(track) {
        this._clearResultRoutes();
        this.fire("selectTrack", {
            track: track.GeoJSON
        });
    },

    highlightRoute: function(route) {
        this.fire("highlightRoute", {
            route: route
        });
    },

    highlightStep: function(step) {
        this.fire("highlightStep", {
            step: step
        });
    },

    enableProvider: function(provider, is_enabled) {
        if (
            this.options.available_providers.indexOf(provider) > -1 &&
            this.options.enabled_providers.indexOf(provider) === -1 &&
            is_enabled
        ) {
            this.options.enabled_providers.push(provider);
        }
        if (
            this.options.available_providers.indexOf(provider) > -1 &&
            this.options.enabled_providers.indexOf(provider) > -1 &&
            !is_enabled
        ) {
            var i = this.options.enabled_providers.indexOf(provider);
            if (i > -1) {
                this.options.enabled_providers.splice(i, 1);
            }
        }
        this.directions.routes.features = [];
        this.options.enabled_providers.forEach(function(p) {
            this.directions.routes.features.push(
                this.directions[p].routes[0].geometry
            );
        }, this);
        this.fire("load", this.directions);
    },

    queryURL: function(opts) {
        var provider = opts.provider.toLowerCase();
        var template = this.options[provider].api_template;
        var points = "";
        if (provider === "mapbox") {
            points = [this.getOrigin(), this.getDestination()]
                .map(function(p) {
                    return p.geometry.coordinates;
                })
                .join(";");
            return L.Util.template(template, {
                token: this.options.mapbox.key,
                waypoints: points
            });
        }
        if (provider === "openrouteservice") {
            points = [this.getOrigin(), this.getDestination()]
                .map(function(p) {
                    return p.geometry.coordinates;
                })
                .join("%7C");
            if (opts.hasOwnProperty("preference")) {
                this.options.openrouteservice.preference = opts.preference;
            }
            if (opts.hasOwnProperty("profile")) {
                this.options.openrouteservice.profile = opts.profile;
            }
            return L.Util.template(template, {
                token: this.options.openrouteservice.key,
                coordinates: points,
                preference: this.options.openrouteservice.preference,
                profile: this.options.openrouteservice.profile
            });
        }
        if (provider === "google") {
            var origin_coords = this.getOrigin().geometry.coordinates.slice();
            var dest_coords = this.getDestination().geometry.coordinates.slice();
            return L.Util.template(template, {
                token: this.options.google.key,
                origin: origin_coords.reverse().join(","),
                destination: dest_coords.reverse().join(",")
            });
        }

        return null;
    },

    _clearResultRoutes: function() {
        this.options.available_providers.forEach(function(p) {
            if (this.directions.hasOwnProperty(p)) {
                this.directions[p] = undefined;
            }
        }, this);
        this.options.enabled_providers = [];
        this.directions.routes = {
            type: "FeatureCollection",
            features: []
        };
        this.fire("checkmapbox", { checked: false });
        this.fire("checkgoogle", { checked: false });
        this.fire("checkors", { checked: false });
    },

    _constructRoutingResult: function(resp, provider) {
        this.directions[provider] = resp;
        this.directions[provider].enabled = true;
        if (provider === "mapbox") {
            this.directions[provider].origin = resp.waypoints[0];
            this.directions[provider].destination = resp.waypoints.slice(-1)[0];
            this.directions[provider].waypoints.forEach(function(wp) {
                wp.geometry = {
                    type: "Point",
                    coordinates: wp.location
                };
                wp.properties = {
                    name: wp.name
                };
            });
            this.directions[provider].waypoints = resp.waypoints.slice(1, -1);
        }
        if (provider === "openrouteservice") {
            this.directions[provider].origin = resp.info.query.coordinates[0];
            this.directions[provider].destination =
                resp.info.query.coordinates[1];
            this.directions[provider].waypoints = [];
        }
        if (provider === "mapbox" || provider === "openrouteservice") {
            this.directions[provider].routes.forEach(function(route) {
                route.geometry = {
                    type: "Feature",
                    properties: this.options[provider].path_style,
                    geometry: {
                        type: "LineString",
                        coordinates: polyline
                            .decode(route.geometry)
                            .map(function(c) {
                                return c.reverse();
                            })
                    }
                };
            }, this);
        }
        if (provider === "google") {
            this.directions[provider].origin = this.origin;
            this.directions[provider].destination = this.destination;
            this.directions[provider].waypoints = [];
            this.directions[provider].routes.forEach(function(route) {
                route.geometry = {
                    type: "Feature",
                    properties: this.options[provider].path_style,
                    geometry: {
                        type: "LineString",
                        coordinates: polyline
                            .decode(route.overview_polyline.points)
                            .map(function(c) {
                                return c.reverse();
                            })
                    }
                };
            }, this);
        }
    },

    queryable: function() {
        return this.getOrigin() && this.getDestination();
    },

    query: function(opts) {
        if (!opts) return this;
        if (!this.queryable()) return this;

        if (this._query) {
            this._query.abort();
        }

        if (this._requests && this._requests.length)
            this._requests.forEach(function(getRequest) {
                getRequest.abort();
            });
        this._requests = [];

        var q = queue();

        var pts = [this.origin, this.destination].concat(this._waypoints);
        for (var i in pts) {
            if (
                !pts[i].geometry.coordinates ||
                !pts[i].properties.hasOwnProperty("name")
            ) {
                q.defer(L.bind(this._geocode, this), pts[i], opts.proximity);
            }
        }

        q.await(
            L.bind(function(err) {
                if (err) {
                    return this.fire("error", {
                        error: err.message
                    });
                }

                this._query = getRequest(
                    this.queryURL(opts),
                    L.bind(function(err, resp) {
                        this._query = null;

                        if (err) {
                            return this.fire("error", {
                                error: err.message
                            });
                        }

                        this._constructRoutingResult(resp, opts.provider);
                        if (!this.origin.properties.name) {
                            this.origin = this.directions.origin;
                        } else {
                            this.directions.origin = this.origin;
                        }

                        if (!this.destination.properties.name) {
                            this.destination = this.directions.destination;
                        } else {
                            this.directions.destination = this.destination;
                        }
                        this.enableProvider(opts.provider, true);
                    }, this),
                    this
                );
            }, this)
        );

        return this;
    },

    _geocode: function(waypoint, proximity, cb) {
        if (!this._requests) this._requests = [];
        this._requests.push(
            getRequest(
                L.Util.template(this.options.mapbox.geocoder_template, {
                    query: waypoint.properties.query,
                    token: this.options.mapbox.key || L.mapbox.accessToken,
                    proximity: proximity
                        ? [proximity.lng, proximity.lat].join(",")
                        : ""
                }),
                L.bind(function(err, resp) {
                    if (err) {
                        return cb(err);
                    }

                    if (!resp.features || !resp.features.length) {
                        return cb(
                            new Error(
                                "No results found for query " +
                                    waypoint.properties.query
                            )
                        );
                    }

                    waypoint.geometry.coordinates = resp.features[0].center;
                    waypoint.properties.name = resp.features[0].place_name;

                    return cb();
                }, this)
            )
        );
    },

    _unload: function() {
        this._waypoints = [];
        delete this.directions;
        this.fire("unload");
    },

    _normalizeWaypoint: function(waypoint) {
        if (!waypoint || waypoint.type === "Feature") {
            return waypoint;
        }

        var coordinates,
            properties = {};

        if (waypoint instanceof L.LatLng) {
            waypoint = waypoint.wrap();
            coordinates = properties.query = [waypoint.lng, waypoint.lat];
        } else if (typeof waypoint === "string") {
            properties.query = waypoint;
        }

        return {
            type: "Feature",
            geometry: {
                type: "Point",
                coordinates: coordinates
            },
            properties: properties
        };
    }
});

module.exports = function(options) {
    return new Directions(options);
};

},{"./get_request":10,"@mapbox/polyline":4,"queue-async":6}],8:[function(require,module,exports){
'use strict';

var d3 = require('../lib/d3'),
    format = require('./format');

module.exports = function (container, directions) {
    var control = {}, map;

    control.addTo = function (_) {
        map = _;
        return control;
    };

    container = d3.select(L.DomUtil.get(container))
        .classed('mapbox-directions-errors', true);

    directions.on('load unload', function () {
        container
            .classed('mapbox-error-active', false)
            .html('');
    });

    directions.on('error', function (e) {
        container
            .classed('mapbox-error-active', true)
            .html('')
            .append('span')
            .attr('class', 'mapbox-directions-error')
            .text(e.error);

        container
            .insert('span', 'span')
            .attr('class', 'mapbox-directions-icon mapbox-error-icon');
    });

    return control;
};

},{"../lib/d3":2,"./format":9}],9:[function(require,module,exports){
'use strict';

module.exports = {
    duration: function (s) {
        var m = Math.floor(s / 60),
            h = Math.floor(m / 60);
        s %= 60;
        m %= 60;
        if (h === 0 && m === 0) return s + ' s';
        if (h === 0) return m + ' min';
        return h + ' h ' + m + ' min';
    },

    imperial: function (m) {
        var mi = m / 1609.344;
        if (mi >= 100) return mi.toFixed(0) + ' mi';
        if (mi >= 10)  return mi.toFixed(1) + ' mi';
        if (mi >= 0.1) return mi.toFixed(2) + ' mi';
        return (mi * 5280).toFixed(0) + ' ft';
    },

    metric: function (m) {
        if (m >= 100000) return (m / 1000).toFixed(0) + ' km';
        if (m >= 10000)  return (m / 1000).toFixed(1) + ' km';
        if (m >= 100)    return (m / 1000).toFixed(2) + ' km';
        return m.toFixed(0) + ' m';
    }
};

},{}],10:[function(require,module,exports){
'use strict';

var corslite = require('@mapbox/corslite');

module.exports = function(url, callback) {
    return corslite(url, function (err, resp) {
        if (err && err.type === 'abort') {
            return;
        }

        if (err && !err.responseText) {
            return callback(err);
        }

        resp = resp || err;

        try {
            resp = JSON.parse(resp.responseText);
        } catch (e) {
            return callback(new Error(resp.responseText));
        }

        if (resp.error) {
            return callback(new Error(resp.error));
        }

        return callback(null, resp);
    });
};

},{"@mapbox/corslite":3}],11:[function(require,module,exports){
"use strict";

var d3 = require("../lib/d3");

module.exports = function(container, directions) {
    var control = {},
        map;
    var origChange = false,
        destChange = false;

    control.addTo = function(_) {
        map = _;
        return control;
    };

    container = d3
        .select(L.DomUtil.get(container))
        .classed("mapbox-directions-inputs", true);

    var form = container.append("form").on("keypress", function() {
        if (d3.event.keyCode === 13) {
            d3.event.preventDefault();
            if (origChange) directions.setOrigin(originInput.property("value"));
            if (destChange)
                directions.setDestination(destinationInput.property("value"));
            if (directions.queryable())
                for (var key in directionProviders) {
                    if (
                        directionProviders.hasOwnProperty(key) &&
                        directionProviders[key] === true
                    ) {
                        directions.query({
                            proximity: map.getCenter(),
                            provider: key
                        });
                    }
                }
            origChange = false;
            destChange = false;
        }
    });

    var origin = form.append("div").attr("class", "mapbox-directions-origin");

    origin
        .append("label")
        .attr("class", "mapbox-form-label")
        .on("click", function() {
            if (directions.getOrigin() instanceof L.LatLng) {
                map.panTo(directions.getOrigin());
            }
        })
        .append("span")
        .attr("class", "mapbox-directions-icon mapbox-depart-icon");

    var originInput = origin
        .append("input")
        .attr("type", "text")
        .attr("required", "required")
        .attr("id", "air-origin-input")
        .attr("placeholder", "Start")
        .on("input", function() {
            if (!origChange) origChange = true;
        });

    origin
        .append("div")
        .attr("class", "mapbox-directions-icon mapbox-close-icon")
        .attr("title", "Clear value")
        .on("click", function() {
            directions.setOrigin(undefined);
        });

    form
        .append("span")
        .attr(
            "class",
            "mapbox-directions-icon mapbox-reverse-icon mapbox-directions-reverse-input"
        )
        .attr("title", "Reverse origin & destination")
        .on("click", function() {
            for (var key in directionProviders) {
                if (
                    directionProviders.hasOwnProperty(key) &&
                    directionProviders[key] === true
                ) {
                    directions.reverse().query({
                        provider: key
                    });
                }
            }
        });

    var destination = form
        .append("div")
        .attr("class", "mapbox-directions-destination");

    destination
        .append("label")
        .attr("class", "mapbox-form-label")
        .on("click", function() {
            if (directions.getDestination() instanceof L.LatLng) {
                map.panTo(directions.getDestination());
            }
        })
        .append("span")
        .attr("class", "mapbox-directions-icon mapbox-arrive-icon");

    var destinationInput = destination
        .append("input")
        .attr("type", "text")
        .attr("required", "required")
        .attr("id", "air-destination-input")
        .attr("placeholder", "End")
        .on("input", function() {
            if (!destChange) destChange = true;
        });

    destination
        .append("div")
        .attr("class", "mapbox-directions-icon mapbox-close-icon")
        .attr("title", "Clear value")
        .on("click", function() {
            directions.setDestination(undefined);
        });

    var directionProviders = {
        mapbox: false,
        openrouteservice: false,
        google: false
    };

    //Options block for Mapbox cycling path finding
    var mapboxDirections = form
        .append("div")
        .attr("id", "mapbox-directions")
        .attr("class", "mapbox-directions-profile");

    var checkboxMapbox = mapboxDirections
        .append("input")
        .attr("type", "checkbox")
        .attr("name", "enabled")
        .attr("id", "show-mapbox-cycling")
        .property("checked", false)
        .on("change", function(d) {
            if (this.checked) {
                directionProviders.mapbox = true;
                directions.query({
                    provider: "mapbox"
                });
            } else {
                directionProviders.mapbox = false;
                directions.enableProvider("mapbox", false);
            }
        });

    //mapboxDirections.append('h3')
    //.attr('value', 'MAPBOX')
    //.attr('style', 'margin: 5px 0px 0px 5px')
    //.text('MAPBOX DIRECTIONS');

    mapboxDirections
        .append("label")
        .attr("class", "air-heading-label")
        .attr("for", "show-mapbox-cycling")
        .text("MAPBOX DIRECTIONS");

    var googleDirections = form
        .append("div")
        .attr("id", "google-directions-profile")
        .attr("class", "mapbox-directions-profile");

    var checkboxGoogle = googleDirections
        .append("input")
        .attr("type", "checkbox")
        .attr("name", "enabled")
        .attr("id", "show-google-cycling")
        .property("checked", false)
        .on("change", function(d) {
            if (this.checked) {
                directionProviders.google = true;
                directions.query({
                    provider: "google"
                });
            } else {
                directionProviders.google = false;
                directions.enableProvider("google", false);
            }
        });

    googleDirections
        .append("label")
        .attr("class", "air-heading-label")
        .attr("for", "show-google-cycling")
        .text("GOOGLE MAPS");

    //Options block for OpenRouteService cycling path finding
    var orsDirections = form
        .append("div")
        .attr("id", "ors-directions")
        .attr("class", "mapbox-directions-profile");

    var checkboxORS = orsDirections
        .append("input")
        .attr("type", "checkbox")
        .attr("name", "enabled")
        .attr("id", "show-ors-cycling")
        .property("checked", false)
        .on("change", function(d) {
            if (this.checked) {
                directionProviders.openrouteservice = true;
                changeORSCyclingOption();
                disableORSRadioBtns(false);
            } else {
                directionProviders.openrouteservice = false;
                directions.enableProvider("openrouteservice", false);
                disableORSRadioBtns(true);
            }
        });

    orsDirections
        .append("label")
        .attr("class", "air-heading-label")
        .attr("for", "show-ors-cycling")
        .text("OPENROUTESERVICE");

    var orsCyclingOptions = orsDirections.append("div");
    var orsCyclingRegular = orsCyclingOptions
        .append("input")
        .attr("type", "radio")
        .attr("name", "orsProfileBicycle")
        .attr("id", "ors-bicycle-regular")
        .attr("value", "cycling-regular")
        .property("checked", true)
        .property("disabled", true)
        .on("change", changeORSCyclingOption);

    orsCyclingOptions
        .append("label")
        .attr("for", "ors-bicycle-regular")
        .html("Normal");

    var orsCyclingSafe = orsCyclingOptions
        .append("input")
        .attr("type", "radio")
        .attr("name", "orsProfileBicycle")
        .attr("id", "ors-bicycle-safe")
        .attr("value", "cycling-safe")
        .property("disabled", true)
        .on("change", changeORSCyclingOption);

    orsCyclingOptions
        .append("label")
        .attr("for", "ors-bicycle-safe")
        .html("Safest");

    var orsCyclingTour = orsCyclingOptions
        .append("input")
        .attr("type", "radio")
        .attr("name", "orsProfileBicycle")
        .attr("id", "ors-bicycle-tour")
        .attr("value", "cycling-tour")
        .property("disabled", true)
        .on("change", changeORSCyclingOption);

    orsCyclingOptions
        .append("label")
        .attr("for", "ors-bicycle-tour")
        .html("Touring bike");

    var orsCyclingMountain = orsCyclingOptions
        .append("input")
        .attr("type", "radio")
        .attr("name", "orsProfileBicycle")
        .attr("id", "ors-bicycle-mountain")
        .attr("value", "cycling-mountain")
        .property("disabled", true)
        .on("change", changeORSCyclingOption);

    orsCyclingOptions
        .append("label")
        .attr("for", "ors-bicycle-mountain")
        .html("Mountain bike");

    var orsCyclingRoad = orsCyclingOptions
        .append("input")
        .attr("type", "radio")
        .attr("name", "orsProfileBicycle")
        .attr("id", "ors-bicycle-road")
        .attr("value", "cycling-road")
        .property("disabled", true)
        .on("change", changeORSCyclingOption);

    orsCyclingOptions
        .append("label")
        .attr("for", "ors-bicycle-road")
        .html("Road bike");

    var orsCyclingElectric = orsCyclingOptions
        .append("input")
        .attr("type", "radio")
        .attr("name", "orsProfileBicycle")
        .attr("id", "ors-bicycle-electric")
        .attr("value", "cycling-electric")
        .property("disabled", true)
        .on("change", changeORSCyclingOption);

    orsCyclingOptions
        .append("label")
        .attr("for", "ors-bicycle-electric")
        .html("e-bike");

    function changeORSCyclingOption() {
        var selectedOption = d3
            .select("input[name=orsProfileBicycle]:checked")
            .attr("value");
        directions.query({
            provider: "openrouteservice",
            profile: selectedOption
        });
    }

    function disableORSRadioBtns(is_disabled) {
        d3.selectAll("input[name='orsProfileBicycle']")[0].forEach(function(r) {
            r.disabled = is_disabled;
        });
    }

    function format(waypoint) {
        if (!waypoint) {
            return "";
        } else if (waypoint.properties.name) {
            return waypoint.properties.name;
        } else if (waypoint.geometry.coordinates) {
            var precision = Math.max(
                0,
                Math.ceil(Math.log(map.getZoom()) / Math.LN2)
            );
            return (
                waypoint.geometry.coordinates[0].toFixed(precision) +
                ", " +
                waypoint.geometry.coordinates[1].toFixed(precision)
            );
        } else {
            return waypoint.properties.query || "";
        }
    }

    directions
        .on("origin", function(e) {
            originInput.property("value", format(e.origin));
        })
        .on("destination", function(e) {
            destinationInput.property("value", format(e.destination));
        })
        .on("checkmapbox", function(e) {
            checkboxMapbox.property("checked", false);
        })
        .on("checkgoogle", function(e) {
            checkboxGoogle.property("checked", false);
        })
        .on("checkors", function(e) {
            checkboxORS.property("checked", false);
        })
        .on("load", function(e) {
            originInput.property("value", format(e.origin));
            destinationInput.property("value", format(e.destination));
        });

    return control;
};

},{"../lib/d3":2}],12:[function(require,module,exports){
"use strict";

var debounce = require("debounce");

var Layer = L.LayerGroup.extend({
    options: {
        readonly: false
    },

    initialize: function(directions, options) {
        L.setOptions(this, options);
        this._directions = directions || new L.Directions();
        L.LayerGroup.prototype.initialize.apply(this);

        this._drag = debounce(L.bind(this._drag, this), 100);

        this.originMarker = L.marker([0, 0], {
            draggable: !this.options.readonly,
            icon: L.mapbox.marker.icon({
                "marker-size": "medium",
                "marker-color": "#3BB2D0",
                "marker-symbol": "a"
            })
        }).on("drag", this._drag, this);

        this.destinationMarker = L.marker([0, 0], {
            draggable: !this.options.readonly,
            icon: L.mapbox.marker.icon({
                "marker-size": "medium",
                "marker-color": "#444",
                "marker-symbol": "b"
            })
        }).on("drag", this._drag, this);

        this.stepMarker = L.marker([0, 0], {
            icon: L.divIcon({
                className:
                    "mapbox-marker-drag-icon mapbox-marker-drag-icon-step",
                iconSize: new L.Point(12, 12)
            })
        });

        this.dragMarker = L.marker([0, 0], {
            draggable: !this.options.readonly,
            icon: this._waypointIcon()
        });

        this.dragMarker
            .on("dragstart", this._dragStart, this)
            .on("drag", this._drag, this)
            .on("dragend", this._dragEnd, this);

        this.routeLayer = L.mapbox.featureLayer();
        this.routeHighlightLayer = L.mapbox.featureLayer();
        this.trackLayer = L.mapbox.featureLayer();
    },

    onAdd: function() {
        L.LayerGroup.prototype.onAdd.apply(this, arguments);

        if (!this.options.readonly) {
            this._map
                .on("click", this._click, this)
                .on("mousemove", this._mousemove, this);
        }

        this._directions
            .on("origin", this._origin, this)
            .on("destination", this._destination, this)
            .on("load", this._load, this)
            .on("unload", this._unload, this)
            .on("selectRoute", this._selectRoute, this)
            .on("selectTrack", this._selectTrack, this)
            .on("highlightRoute", this._highlightRoute, this)
            .on("highlightStep", this._highlightStep, this);
    },

    onRemove: function() {
        this._directions
            .off("origin", this._origin, this)
            .off("destination", this._destination, this)
            .off("load", this._load, this)
            .off("unload", this._unload, this)
            .off("selectRoute", this._selectRoute, this)
            .off("selectTrack", this._selectTrack, this)
            .off("highlightRoute", this._highlightRoute, this)
            .off("highlightStep", this._highlightStep, this);

        this._map
            .off("click", this._click, this)
            .off("mousemove", this._mousemove, this);

        L.LayerGroup.prototype.onRemove.apply(this, arguments);
    },

    _click: function(e) {
        if (!this._directions.getOrigin()) {
            this._directions.setOrigin(e.latlng);
        } else if (!this._directions.getDestination()) {
            this._directions.setDestination(e.latlng);
        }

        //if (this._directions.queryable()) {
        //this._directions.query();
        //}
    },

    _mousemove: function(e) {
        if (
            !this.routeLayer ||
            !this.hasLayer(this.routeLayer) ||
            this._currentWaypoint !== undefined
        ) {
            return;
        }

        var p = this._routePolyline().closestLayerPoint(e.layerPoint);

        if (!p || p.distance > 15) {
            return this.removeLayer(this.dragMarker);
        }

        var m = this._map.project(e.latlng),
            o = this._map.project(this.originMarker.getLatLng()),
            d = this._map.project(this.destinationMarker.getLatLng());

        if (o.distanceTo(m) < 15 || d.distanceTo(m) < 15) {
            return this.removeLayer(this.dragMarker);
        }

        this.dragMarker.setLatLng(this._map.layerPointToLatLng(p));
        this.addLayer(this.dragMarker);
    },

    _origin: function(e) {
        if (e.origin && e.origin.geometry.coordinates) {
            this.originMarker.setLatLng(
                L.GeoJSON.coordsToLatLng(e.origin.geometry.coordinates)
            );
            this.addLayer(this.originMarker);
        } else {
            this.removeLayer(this.originMarker);
        }
    },

    _destination: function(e) {
        if (e.destination && e.destination.geometry.coordinates) {
            this.destinationMarker.setLatLng(
                L.GeoJSON.coordsToLatLng(e.destination.geometry.coordinates)
            );
            this.addLayer(this.destinationMarker);
        } else {
            this.removeLayer(this.destinationMarker);
        }
    },

    _load: function(e) {
        this._origin(e);
        this._destination(e);
    },

    _unload: function() {
        this.removeLayer(this.routeLayer);
        this.removeLayer(this.trackLayer);
    },

    _selectRoute: function(e) {
        this.routeLayer.clearLayers().setGeoJSON(e.route);
        this.addLayer(this.routeLayer);
    },

    _selectTrack: function(e) {
        this.trackLayer.clearLayers().setGeoJSON(e.track);
        this.addLayer(this.trackLayer);
        this.removeLayer(this.routeLayer);
    },

    _highlightRoute: function(e) {
        if (e.route) {
            this.routeHighlightLayer.clearLayers().setGeoJSON(e.route.geometry);
            this.addLayer(this.routeHighlightLayer);
        } else {
            this.removeLayer(this.routeHighlightLayer);
        }
    },

    _highlightStep: function(e) {
        if (e.step && e.step.loc) {
            this.stepMarker.setLatLng(L.GeoJSON.coordsToLatLng(e.step.loc));
            this.addLayer(this.stepMarker);
        } else {
            this.removeLayer(this.stepMarker);
        }
    },

    _routePolyline: function() {
        return this.routeLayer.getLayers()[0];
    },

    _findNearestRouteSegment: function(latLng) {
        var min = Infinity,
            index,
            p = this._map.latLngToLayerPoint(latLng),
            positions = this._routePolyline()._originalPoints;

        for (var i = 1; i < positions.length; i++) {
            var d = L.LineUtil._sqClosestPointOnSegment(
                p,
                positions[i - 1],
                positions[i],
                true
            );
            if (d < min) {
                min = d;
                index = i;
            }
        }

        return index;
    },

    _waypointIcon: function() {
        return L.divIcon({
            className: "mapbox-marker-drag-icon",
            iconSize: new L.Point(12, 12)
        });
    }
});

module.exports = function(directions, options) {
    return new Layer(directions, options);
};

},{"debounce":5}],13:[function(require,module,exports){
/* @flow */
var dom = document; // this to claim that we use the dom api, not representative of the page document

var PagingControl = function(
    element /*: Element */ ,
    options /*: ?Object */
) {
    this.element = element;

    options = options || {};
    options.displayed = options.displayed || 10;
    options.total = options.total || 10;

    this.update(options);
    this.selected = 1;

    // set empty event handlers
    this.onSelected(function() {});
};

PagingControl.prototype.clear = function() {
    Array.prototype.forEach.call(
        this.element.querySelectorAll('a[rel=page]'),
        function(node) {
            node.remove();
        }
    );
};

var calcRange = function(focus, displayed, total) {
    var half = Math.floor(displayed / 2);
    var pageMax = Math.min(total, displayed);
    if (focus - half < 1) {
        return {
            start: 1,
            end: pageMax
        };
    }
    if (focus + half > total) {
        return {
            start: total - displayed + 1,
            end: total
        };
    }
    return {
        start: focus - half,
        end: focus + half
    };
};

PagingControl.prototype.onSelected = function(handler) {
    var self = this;
    var displayed = this.options.displayed;

    this.onSelectedHandler = function(pageNo) {
        self.clear();
        var range = calcRange(pageNo, displayed, self.options.total);
        self.renderPages(range.start, range.end, pageNo);
        return handler(pageNo);
    };
};

PagingControl.prototype.renderPages = function(start, end, selected) {
    var self = this;
    var genHandler = function(pageNo) {
        return function() {
            self.onSelectedHandler(pageNo);
        };
    };

    for (var i = start; i <= end; i++) {
        var page = document.createElement('a');
        page.addEventListener('click', genHandler(i));
        page.rel = 'page';
        page.href = '#';
        page.textContent = i;
        if (i === selected) {
            page.classList.add('selected');
        }

        this.element.appendChild(page);
    }
};

PagingControl.prototype.update = function(options) {
    this.clear();
    this.options = options;
    this.renderPages(1, Math.min(options.total, options.displayed), 1);
};

module.exports = PagingControl;

},{}],14:[function(require,module,exports){
"use strict";

var d3 = require("../lib/d3"),
    format = require("./format");

module.exports = function(container, directions) {
    var control = {},
        map,
        selection = 0;

    control.addTo = function(_) {
        map = _;
        return control;
    };

    container = d3
        .select(L.DomUtil.get(container))
        .classed("mapbox-directions-routes", true);

    directions.on("error", function() {
        container.html("");
    });

    directions.on("load", function(e) {
        container.html("");

        var routes = container
            .append("ul")
            .selectAll("li")
            .data(e.routes)
            .enter()
            .append("li")
            .attr("class", "mapbox-directions-route");

        routes
            .append("div")
            .attr("class", "mapbox-directions-route-heading")
            .text(function(route) {
                return "Route " + (e.routes.indexOf(route) + 1);
            });

        routes
            .append("div")
            .attr("class", "mapbox-directions-route-summary")
            .text(function(route) {
                return route.summary;
            });

        routes
            .append("div")
            .attr("class", "mapbox-directions-route-details")
            .text(function(route) {
                return (
                    format[directions.options.units](route.distance) +
                    ", " +
                    format.duration(route.duration)
                );
            });

        routes.on("mouseover", function(route) {
            directions.highlightRoute(route);
        });

        routes.on("mouseout", function() {
            directions.highlightRoute(null);
        });

        routes.on("click", function(route) {
            directions.selectRoute(route);
        });

        directions.selectRoute(e.routes);
    });

    directions.on("selectRoute", function(e) {
        container
            .selectAll(".mapbox-directions-route")
            .classed("mapbox-directions-route-active", function(route) {
                return route === e.route;
            });
    });

    return control;
};

},{"../lib/d3":2,"./format":9}],15:[function(require,module,exports){
/* @flow */

var renderRow = function(container, data) {
    var row = container.insertRow();
    data.forEach(function(str) {
        var cell = row.insertCell();
        cell.textContent = str;
    });
    return row;
};

var renderHeader = function(container, data) {
    var row = container.insertRow();
    data.forEach(function(str) {
        var th = document.createElement('th');
        th.innerHTML = str;
        row.appendChild(th);
    });
    return row;
};

var TableControl = function(
    element /*: Object */, /* TableElement */
    headers /*: [string] */,
    model /*: ?[[string]] */
) {
    renderHeader(element.createTHead(), headers);
    this.tbody = element.createTBody();
    this.bind(model || []);
};

TableControl.prototype.clear = function() {
    while (this.tbody.hasChildNodes()) {   
        this.tbody.removeChild(this.tbody.firstChild);
    }
};

TableControl.prototype.onSelected = function(handler) {
    this.onSelectedHandler = handler;
};

TableControl.prototype.bind = function(model) {
    this.clear();
    // deal with closure
    var self = this;
    model.forEach(function(data) {
        var row = renderRow(self.tbody, data);
        row.addEventListener('click', function() {
            if (self.onSelectedHandler) {
                self.onSelectedHandler(data);
            }
        });
    });
};

module.exports = TableControl;

},{}],16:[function(require,module,exports){
"use strict";

var tableControl = require("./table_control.js"),
    pagingControl = require("./paging_control.js"),
    getRequest = require("./get_request.js");

module.exports = function(container, directions) {
    var control = {},
        map;
    var origChange = false,
        destChange = false;
    var TRACKINFO_API_URL = "https://luliu.me/tracks/api/v1/trackinfo";
    var TRACK_API_URL = "https://luliu.me/tracks/api/v1/tracks";

    control.addTo = function(_) {
        map = _;
        return control;
    };

    // get page 1 of trackinfo as init data for the table
    // Web browser compatibility:
    // for IE7+, Firefox, Chrome, Opera, Safari
    container = document.getElementById(container);
    container.insertAdjacentHTML(
        "afterbegin",
        '<table id="tracks-table" class="prose air-tracks"></table>'
    );
    container.insertAdjacentHTML(
        "beforeend",
        '<div id="paging" data-control="paging"></div>'
    );

    var trackinfoKeys = [
            "ID",
            "Segments",
            "2D length",
            "3D length",
            "Moving time",
            "Stopped time",
            "Max speed",
            "Uphill",
            "Downhill",
            "Started at",
            "Ended at",
            "Points",
            "Start lon",
            "Start lat",
            "End lon",
            "End lat"
        ],
        values = [];
    var page = 1,
        totalPages = 1,
        numResults = 1;
    var tc = new tableControl(
        document.getElementById("tracks-table"),
        trackinfoKeys,
        values
    );
    var pg = new pagingControl(document.getElementById("paging"), {
        displayed: 0,
        total: 0
    });

    var trackinfoXhr = new XMLHttpRequest();
    trackinfoXhr.onreadystatechange = function() {
        if (trackinfoXhr.readyState === 4 && trackinfoXhr.status === 200) {
            var trackinfoData = JSON.parse(trackinfoXhr.responseText);
            totalPages = trackinfoData.total_pages;
            page = trackinfoData.page;
            numResults = trackinfoData.num_results;
            values = [];
            trackinfoData.objects.forEach(function(data) {
                var row = trackinfoKeys.map(function(key) {
                    return data[key];
                });
                values.push(row);
            });
            tc.bind(values);
            pg.update({ displayed: 10, total: totalPages });
        }
    };
    trackinfoXhr.open("GET", TRACKINFO_API_URL, true);
    trackinfoXhr.send();

    tc.onSelected(function(data) {
        var startPos = L.GeoJSON.coordsToLatLng([data[12], data[13]]);
        var endPos = L.GeoJSON.coordsToLatLng([data[14], data[15]]);
        directions.setOrigin(startPos);
        directions.setDestination(endPos);
        var southWest = L.latLng(
                Math.min(startPos.lat, endPos.lat),
                Math.min(startPos.lng, endPos.lng)
            ),
            northEast = L.latLng(
                Math.max(startPos.lat, endPos.lat),
                Math.max(startPos.lng, endPos.lng)
            ),
            bounds = L.latLngBounds(southWest, northEast);
        map.fitBounds(bounds);
        // Web browser compatibility:
        // IE7+, Firefox, Chrome, Opera, Safari
        var trackXhr = new XMLHttpRequest();
        trackXhr.onreadystatechange = function() {
            if (trackXhr.readyState === 4 && trackXhr.status === 200) {
                var trackData = JSON.parse(trackXhr.responseText);
                directions.selectTrack(trackData);
            }
        };
        trackXhr.open("GET", TRACK_API_URL + "/" + data[0], true);
        trackXhr.send();
    });

    pg.onSelected(function(pageNo) {
        var pagedTrackinfoXhr = new XMLHttpRequest();
        pagedTrackinfoXhr.onreadystatechange = function() {
            if (
                pagedTrackinfoXhr.readyState === 4 &&
                pagedTrackinfoXhr.status === 200
            ) {
                var trackinfoData = JSON.parse(pagedTrackinfoXhr.responseText);
                // The following 3 variables can be aquired from the response,
                // but useless for the moment
                //totalPages = trackinfoData.total_pages;
                //page = trackinfoData.page;
                //numResults = trackinfoData.num_results;
                values = [];
                trackinfoData.objects.forEach(function(data) {
                    var row = trackinfoKeys.map(function(key) {
                        return data[key];
                    });
                    values.push(row);
                });
                tc.bind(values);
            }
        };
        pagedTrackinfoXhr.open(
            "GET",
            TRACKINFO_API_URL + "?page=" + pageNo,
            true
        );
        pagedTrackinfoXhr.send();
    });

    return control;
};

},{"./get_request.js":10,"./paging_control.js":13,"./table_control.js":15}]},{},[1])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9sbGl1L1Byb2plY3RzL2Fpci5qcy9pbmRleC5qcyIsIi9Vc2Vycy9sbGl1L1Byb2plY3RzL2Fpci5qcy9saWIvZDMuanMiLCIvVXNlcnMvbGxpdS9Qcm9qZWN0cy9haXIuanMvbm9kZV9tb2R1bGVzL0BtYXBib3gvY29yc2xpdGUvY29yc2xpdGUuanMiLCIvVXNlcnMvbGxpdS9Qcm9qZWN0cy9haXIuanMvbm9kZV9tb2R1bGVzL0BtYXBib3gvcG9seWxpbmUvc3JjL3BvbHlsaW5lLmpzIiwiL1VzZXJzL2xsaXUvUHJvamVjdHMvYWlyLmpzL25vZGVfbW9kdWxlcy9kZWJvdW5jZS9pbmRleC5qcyIsIi9Vc2Vycy9sbGl1L1Byb2plY3RzL2Fpci5qcy9ub2RlX21vZHVsZXMvcXVldWUtYXN5bmMvYnVpbGQvcXVldWUuanMiLCIvVXNlcnMvbGxpdS9Qcm9qZWN0cy9haXIuanMvc3JjL2RpcmVjdGlvbnMuanMiLCIvVXNlcnMvbGxpdS9Qcm9qZWN0cy9haXIuanMvc3JjL2Vycm9yc19jb250cm9sLmpzIiwiL1VzZXJzL2xsaXUvUHJvamVjdHMvYWlyLmpzL3NyYy9mb3JtYXQuanMiLCIvVXNlcnMvbGxpdS9Qcm9qZWN0cy9haXIuanMvc3JjL2dldF9yZXF1ZXN0LmpzIiwiL1VzZXJzL2xsaXUvUHJvamVjdHMvYWlyLmpzL3NyYy9pbnB1dF9jb250cm9sLmpzIiwiL1VzZXJzL2xsaXUvUHJvamVjdHMvYWlyLmpzL3NyYy9sYXllci5qcyIsIi9Vc2Vycy9sbGl1L1Byb2plY3RzL2Fpci5qcy9zcmMvcGFnaW5nX2NvbnRyb2wuanMiLCIvVXNlcnMvbGxpdS9Qcm9qZWN0cy9haXIuanMvc3JjL3JvdXRlc19jb250cm9sLmpzIiwiL1VzZXJzL2xsaXUvUHJvamVjdHMvYWlyLmpzL3NyYy90YWJsZV9jb250cm9sLmpzIiwiL1VzZXJzL2xsaXUvUHJvamVjdHMvYWlyLmpzL3NyYy90cmFja3NfY29udHJvbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICghTC5tYXBib3gpIHRocm93IG5ldyBFcnJvcihcImluY2x1ZGUgbWFwYm94LmpzIGJlZm9yZSBhaXIuanNcIik7XG5cbkwuYWlyID0gcmVxdWlyZShcIi4vc3JjL2RpcmVjdGlvbnNcIik7XG5MLmFpci5mb3JtYXQgPSByZXF1aXJlKFwiLi9zcmMvZm9ybWF0XCIpO1xuTC5haXIubGF5ZXIgPSByZXF1aXJlKFwiLi9zcmMvbGF5ZXJcIik7XG5MLmFpci5pbnB1dENvbnRyb2wgPSByZXF1aXJlKFwiLi9zcmMvaW5wdXRfY29udHJvbFwiKTtcbkwuYWlyLmVycm9yc0NvbnRyb2wgPSByZXF1aXJlKFwiLi9zcmMvZXJyb3JzX2NvbnRyb2xcIik7XG5MLmFpci5yb3V0ZXNDb250cm9sID0gcmVxdWlyZShcIi4vc3JjL3JvdXRlc19jb250cm9sXCIpO1xuLy8gTC5haXIuaW5zdHJ1Y3Rpb25zQ29udHJvbCA9IHJlcXVpcmUoJy4vc3JjL2luc3RydWN0aW9uc19jb250cm9sJyk7XG5MLmFpci50cmFja3NDb250cm9sID0gcmVxdWlyZShcIi4vc3JjL3RyYWNrc19jb250cm9sLmpzXCIpO1xuIiwiIWZ1bmN0aW9uKCl7XG4gIHZhciBkMyA9IHt2ZXJzaW9uOiBcIjMuNC4xXCJ9OyAvLyBzZW12ZXJcbnZhciBkM19hcnJheVNsaWNlID0gW10uc2xpY2UsXG4gICAgZDNfYXJyYXkgPSBmdW5jdGlvbihsaXN0KSB7IHJldHVybiBkM19hcnJheVNsaWNlLmNhbGwobGlzdCk7IH07IC8vIGNvbnZlcnNpb24gZm9yIE5vZGVMaXN0c1xuXG52YXIgZDNfZG9jdW1lbnQgPSBkb2N1bWVudCxcbiAgICBkM19kb2N1bWVudEVsZW1lbnQgPSBkM19kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgZDNfd2luZG93ID0gd2luZG93O1xuXG4vLyBSZWRlZmluZSBkM19hcnJheSBpZiB0aGUgYnJvd3NlciBkb2VzbuKAmXQgc3VwcG9ydCBzbGljZS1iYXNlZCBjb252ZXJzaW9uLlxudHJ5IHtcbiAgZDNfYXJyYXkoZDNfZG9jdW1lbnRFbGVtZW50LmNoaWxkTm9kZXMpWzBdLm5vZGVUeXBlO1xufSBjYXRjaChlKSB7XG4gIGQzX2FycmF5ID0gZnVuY3Rpb24obGlzdCkge1xuICAgIHZhciBpID0gbGlzdC5sZW5ndGgsIGFycmF5ID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIGFycmF5W2ldID0gbGlzdFtpXTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH07XG59XG52YXIgZDNfc3ViY2xhc3MgPSB7fS5fX3Byb3RvX18/XG5cbi8vIFVudGlsIEVDTUFTY3JpcHQgc3VwcG9ydHMgYXJyYXkgc3ViY2xhc3NpbmcsIHByb3RvdHlwZSBpbmplY3Rpb24gd29ya3Mgd2VsbC5cbmZ1bmN0aW9uKG9iamVjdCwgcHJvdG90eXBlKSB7XG4gIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG59OlxuXG4vLyBBbmQgaWYgeW91ciBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBfX3Byb3RvX18sIHdlJ2xsIHVzZSBkaXJlY3QgZXh0ZW5zaW9uLlxuZnVuY3Rpb24ob2JqZWN0LCBwcm90b3R5cGUpIHtcbiAgZm9yICh2YXIgcHJvcGVydHkgaW4gcHJvdG90eXBlKSBvYmplY3RbcHJvcGVydHldID0gcHJvdG90eXBlW3Byb3BlcnR5XTtcbn07XG5cbmZ1bmN0aW9uIGQzX3ZlbmRvclN5bWJvbChvYmplY3QsIG5hbWUpIHtcbiAgaWYgKG5hbWUgaW4gb2JqZWN0KSByZXR1cm4gbmFtZTtcbiAgbmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnN1YnN0cmluZygxKTtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBkM192ZW5kb3JQcmVmaXhlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICB2YXIgcHJlZml4TmFtZSA9IGQzX3ZlbmRvclByZWZpeGVzW2ldICsgbmFtZTtcbiAgICBpZiAocHJlZml4TmFtZSBpbiBvYmplY3QpIHJldHVybiBwcmVmaXhOYW1lO1xuICB9XG59XG5cbnZhciBkM192ZW5kb3JQcmVmaXhlcyA9IFtcIndlYmtpdFwiLCBcIm1zXCIsIFwibW96XCIsIFwiTW96XCIsIFwib1wiLCBcIk9cIl07XG5cbmZ1bmN0aW9uIGQzX3NlbGVjdGlvbihncm91cHMpIHtcbiAgZDNfc3ViY2xhc3MoZ3JvdXBzLCBkM19zZWxlY3Rpb25Qcm90b3R5cGUpO1xuICByZXR1cm4gZ3JvdXBzO1xufVxuXG52YXIgZDNfc2VsZWN0ID0gZnVuY3Rpb24ocywgbikgeyByZXR1cm4gbi5xdWVyeVNlbGVjdG9yKHMpOyB9LFxuICAgIGQzX3NlbGVjdEFsbCA9IGZ1bmN0aW9uKHMsIG4pIHsgcmV0dXJuIG4ucXVlcnlTZWxlY3RvckFsbChzKTsgfSxcbiAgICBkM19zZWxlY3RNYXRjaGVyID0gZDNfZG9jdW1lbnRFbGVtZW50W2QzX3ZlbmRvclN5bWJvbChkM19kb2N1bWVudEVsZW1lbnQsIFwibWF0Y2hlc1NlbGVjdG9yXCIpXSxcbiAgICBkM19zZWxlY3RNYXRjaGVzID0gZnVuY3Rpb24obiwgcykgeyByZXR1cm4gZDNfc2VsZWN0TWF0Y2hlci5jYWxsKG4sIHMpOyB9O1xuXG4vLyBQcmVmZXIgU2l6emxlLCBpZiBhdmFpbGFibGUuXG5pZiAodHlwZW9mIFNpenpsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIGQzX3NlbGVjdCA9IGZ1bmN0aW9uKHMsIG4pIHsgcmV0dXJuIFNpenpsZShzLCBuKVswXSB8fCBudWxsOyB9O1xuICBkM19zZWxlY3RBbGwgPSBmdW5jdGlvbihzLCBuKSB7IHJldHVybiBTaXp6bGUudW5pcXVlU29ydChTaXp6bGUocywgbikpOyB9O1xuICBkM19zZWxlY3RNYXRjaGVzID0gU2l6emxlLm1hdGNoZXNTZWxlY3Rvcjtcbn1cblxuZDMuc2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBkM19zZWxlY3Rpb25Sb290O1xufTtcblxudmFyIGQzX3NlbGVjdGlvblByb3RvdHlwZSA9IGQzLnNlbGVjdGlvbi5wcm90b3R5cGUgPSBbXTtcblxuXG5kM19zZWxlY3Rpb25Qcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgdmFyIHN1Ymdyb3VwcyA9IFtdLFxuICAgICAgc3ViZ3JvdXAsXG4gICAgICBzdWJub2RlLFxuICAgICAgZ3JvdXAsXG4gICAgICBub2RlO1xuXG4gIHNlbGVjdG9yID0gZDNfc2VsZWN0aW9uX3NlbGVjdG9yKHNlbGVjdG9yKTtcblxuICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTspIHtcbiAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICBzdWJncm91cC5wYXJlbnROb2RlID0gKGdyb3VwID0gdGhpc1tqXSkucGFyZW50Tm9kZTtcbiAgICBmb3IgKHZhciBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47KSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2goc3Vibm9kZSA9IHNlbGVjdG9yLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpO1xuICAgICAgICBpZiAoc3Vibm9kZSAmJiBcIl9fZGF0YV9fXCIgaW4gbm9kZSkgc3Vibm9kZS5fX2RhdGFfXyA9IG5vZGUuX19kYXRhX187XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJncm91cC5wdXNoKG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkM19zZWxlY3Rpb24oc3ViZ3JvdXBzKTtcbn07XG5cbmZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9zZWxlY3RvcihzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgPyBzZWxlY3RvciA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zZWxlY3Qoc2VsZWN0b3IsIHRoaXMpO1xuICB9O1xufVxuXG5kM19zZWxlY3Rpb25Qcm90b3R5cGUuc2VsZWN0QWxsID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgdmFyIHN1Ymdyb3VwcyA9IFtdLFxuICAgICAgc3ViZ3JvdXAsXG4gICAgICBub2RlO1xuXG4gIHNlbGVjdG9yID0gZDNfc2VsZWN0aW9uX3NlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTspIHtcbiAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjspIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBkM19hcnJheShzZWxlY3Rvci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKSk7XG4gICAgICAgIHN1Ymdyb3VwLnBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkM19zZWxlY3Rpb24oc3ViZ3JvdXBzKTtcbn07XG5cbmZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9zZWxlY3RvckFsbChzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgPyBzZWxlY3RvciA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zZWxlY3RBbGwoc2VsZWN0b3IsIHRoaXMpO1xuICB9O1xufVxudmFyIGQzX25zUHJlZml4ID0ge1xuICBzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgeGh0bWw6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLFxuICB4bGluazogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gIHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIlxufTtcblxuZDMubnMgPSB7XG4gIHByZWZpeDogZDNfbnNQcmVmaXgsXG4gIHF1YWxpZnk6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgaSA9IG5hbWUuaW5kZXhPZihcIjpcIiksXG4gICAgICAgIHByZWZpeCA9IG5hbWU7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgcHJlZml4ID0gbmFtZS5zdWJzdHJpbmcoMCwgaSk7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoaSArIDEpO1xuICAgIH1cbiAgICByZXR1cm4gZDNfbnNQcmVmaXguaGFzT3duUHJvcGVydHkocHJlZml4KVxuICAgICAgICA/IHtzcGFjZTogZDNfbnNQcmVmaXhbcHJlZml4XSwgbG9jYWw6IG5hbWV9XG4gICAgICAgIDogbmFtZTtcbiAgfVxufTtcblxuZDNfc2VsZWN0aW9uUHJvdG90eXBlLmF0dHIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcblxuICAgIC8vIEZvciBhdHRyKHN0cmluZyksIHJldHVybiB0aGUgYXR0cmlidXRlIHZhbHVlIGZvciB0aGUgZmlyc3Qgbm9kZS5cbiAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG4gICAgICBuYW1lID0gZDMubnMucXVhbGlmeShuYW1lKTtcbiAgICAgIHJldHVybiBuYW1lLmxvY2FsXG4gICAgICAgICAgPyBub2RlLmdldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpXG4gICAgICAgICAgOiBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG5cbiAgICAvLyBGb3IgYXR0cihvYmplY3QpLCB0aGUgb2JqZWN0IHNwZWNpZmllcyB0aGUgbmFtZXMgYW5kIHZhbHVlcyBvZiB0aGVcbiAgICAvLyBhdHRyaWJ1dGVzIHRvIHNldCBvciByZW1vdmUuIFRoZSB2YWx1ZXMgbWF5IGJlIGZ1bmN0aW9ucyB0aGF0IGFyZVxuICAgIC8vIGV2YWx1YXRlZCBmb3IgZWFjaCBlbGVtZW50LlxuICAgIGZvciAodmFsdWUgaW4gbmFtZSkgdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9hdHRyKHZhbHVlLCBuYW1lW3ZhbHVlXSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fYXR0cihuYW1lLCB2YWx1ZSkpO1xufTtcblxuZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2F0dHIobmFtZSwgdmFsdWUpIHtcbiAgbmFtZSA9IGQzLm5zLnF1YWxpZnkobmFtZSk7XG5cbiAgLy8gRm9yIGF0dHIoc3RyaW5nLCBudWxsKSwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gIGZ1bmN0aW9uIGF0dHJOdWxsKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIGF0dHJOdWxsTlMoKSB7XG4gICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKTtcbiAgfVxuXG4gIC8vIEZvciBhdHRyKHN0cmluZywgc3RyaW5nKSwgc2V0IHRoZSBhdHRyaWJ1dGUgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gIGZ1bmN0aW9uIGF0dHJDb25zdGFudCgpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gYXR0ckNvbnN0YW50TlMoKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsLCB2YWx1ZSk7XG4gIH1cblxuICAvLyBGb3IgYXR0cihzdHJpbmcsIGZ1bmN0aW9uKSwgZXZhbHVhdGUgdGhlIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQsIGFuZCBzZXRcbiAgLy8gb3IgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYXMgYXBwcm9wcmlhdGUuXG4gIGZ1bmN0aW9uIGF0dHJGdW5jdGlvbigpIHtcbiAgICB2YXIgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHggPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB4KTtcbiAgfVxuICBmdW5jdGlvbiBhdHRyRnVuY3Rpb25OUygpIHtcbiAgICB2YXIgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHggPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKTtcbiAgICBlbHNlIHRoaXMuc2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCwgeCk7XG4gIH1cblxuICByZXR1cm4gdmFsdWUgPT0gbnVsbFxuICAgICAgPyAobmFtZS5sb2NhbCA/IGF0dHJOdWxsTlMgOiBhdHRyTnVsbCkgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbilcbiAgICAgIDogKG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkpO1xufVxuZnVuY3Rpb24gZDNfY29sbGFwc2Uocykge1xuICByZXR1cm4gcy50cmltKCkucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG59XG5kMy5yZXF1b3RlID0gZnVuY3Rpb24ocykge1xuICByZXR1cm4gcy5yZXBsYWNlKGQzX3JlcXVvdGVfcmUsIFwiXFxcXCQmXCIpO1xufTtcblxudmFyIGQzX3JlcXVvdGVfcmUgPSAvW1xcXFxcXF5cXCRcXCpcXCtcXD9cXHxcXFtcXF1cXChcXClcXC5cXHtcXH1dL2c7XG5cbmQzX3NlbGVjdGlvblByb3RvdHlwZS5jbGFzc2VkID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG5cbiAgICAvLyBGb3IgY2xhc3NlZChzdHJpbmcpLCByZXR1cm4gdHJ1ZSBvbmx5IGlmIHRoZSBmaXJzdCBub2RlIGhhcyB0aGUgc3BlY2lmaWVkXG4gICAgLy8gY2xhc3Mgb3IgY2xhc3Nlcy4gTm90ZSB0aGF0IGV2ZW4gaWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgRE9NVG9rZW5MaXN0LCBpdFxuICAgIC8vIHByb2JhYmx5IGRvZXNuJ3Qgc3VwcG9ydCBpdCBvbiBTVkcgZWxlbWVudHMgKHdoaWNoIGNhbiBiZSBhbmltYXRlZCkuXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSgpLFxuICAgICAgICAgIG4gPSAobmFtZSA9IGQzX3NlbGVjdGlvbl9jbGFzc2VzKG5hbWUpKS5sZW5ndGgsXG4gICAgICAgICAgaSA9IC0xO1xuICAgICAgaWYgKHZhbHVlID0gbm9kZS5jbGFzc0xpc3QpIHtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICghdmFsdWUuY29udGFpbnMobmFtZVtpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICghZDNfc2VsZWN0aW9uX2NsYXNzZWRSZShuYW1lW2ldKS50ZXN0KHZhbHVlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRm9yIGNsYXNzZWQob2JqZWN0KSwgdGhlIG9iamVjdCBzcGVjaWZpZXMgdGhlIG5hbWVzIG9mIGNsYXNzZXMgdG8gYWRkIG9yXG4gICAgLy8gcmVtb3ZlLiBUaGUgdmFsdWVzIG1heSBiZSBmdW5jdGlvbnMgdGhhdCBhcmUgZXZhbHVhdGVkIGZvciBlYWNoIGVsZW1lbnQuXG4gICAgZm9yICh2YWx1ZSBpbiBuYW1lKSB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX2NsYXNzZWQodmFsdWUsIG5hbWVbdmFsdWVdKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGJvdGggYSBuYW1lIGFuZCBhIHZhbHVlIGFyZSBzcGVjaWZpZWQsIGFuZCBhcmUgaGFuZGxlZCBhcyBiZWxvdy5cbiAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fY2xhc3NlZChuYW1lLCB2YWx1ZSkpO1xufTtcblxuZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2NsYXNzZWRSZShuYW1lKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiKD86XnxcXFxccyspXCIgKyBkMy5yZXF1b3RlKG5hbWUpICsgXCIoPzpcXFxccyt8JClcIiwgXCJnXCIpO1xufVxuXG5mdW5jdGlvbiBkM19zZWxlY3Rpb25fY2xhc3NlcyhuYW1lKSB7XG4gIHJldHVybiBuYW1lLnRyaW0oKS5zcGxpdCgvXnxcXHMrLyk7XG59XG5cbi8vIE11bHRpcGxlIGNsYXNzIG5hbWVzIGFyZSBhbGxvd2VkIChlLmcuLCBcImZvbyBiYXJcIikuXG5mdW5jdGlvbiBkM19zZWxlY3Rpb25fY2xhc3NlZChuYW1lLCB2YWx1ZSkge1xuICBuYW1lID0gZDNfc2VsZWN0aW9uX2NsYXNzZXMobmFtZSkubWFwKGQzX3NlbGVjdGlvbl9jbGFzc2VkTmFtZSk7XG4gIHZhciBuID0gbmFtZS5sZW5ndGg7XG5cbiAgZnVuY3Rpb24gY2xhc3NlZENvbnN0YW50KCkge1xuICAgIHZhciBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IG4pIG5hbWVbaV0odGhpcywgdmFsdWUpO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgdmFsdWUgaXMgYSBmdW5jdGlvbiwgdGhlIGZ1bmN0aW9uIGlzIHN0aWxsIGV2YWx1YXRlZCBvbmx5IG9uY2UgcGVyXG4gIC8vIGVsZW1lbnQgZXZlbiBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2xhc3MgbmFtZXMuXG4gIGZ1bmN0aW9uIGNsYXNzZWRGdW5jdGlvbigpIHtcbiAgICB2YXIgaSA9IC0xLCB4ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB3aGlsZSAoKytpIDwgbikgbmFtZVtpXSh0aGlzLCB4KTtcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBjbGFzc2VkRnVuY3Rpb25cbiAgICAgIDogY2xhc3NlZENvbnN0YW50O1xufVxuXG5mdW5jdGlvbiBkM19zZWxlY3Rpb25fY2xhc3NlZE5hbWUobmFtZSkge1xuICB2YXIgcmUgPSBkM19zZWxlY3Rpb25fY2xhc3NlZFJlKG5hbWUpO1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgICBpZiAoYyA9IG5vZGUuY2xhc3NMaXN0KSByZXR1cm4gdmFsdWUgPyBjLmFkZChuYW1lKSA6IGMucmVtb3ZlKG5hbWUpO1xuICAgIHZhciBjID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmUubGFzdEluZGV4ID0gMDtcbiAgICAgIGlmICghcmUudGVzdChjKSkgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBkM19jb2xsYXBzZShjICsgXCIgXCIgKyBuYW1lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZDNfY29sbGFwc2UoYy5yZXBsYWNlKHJlLCBcIiBcIikpKTtcbiAgICB9XG4gIH07XG59XG5cbmQzX3NlbGVjdGlvblByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmIChuIDwgMykge1xuXG4gICAgLy8gRm9yIHN0eWxlKG9iamVjdCkgb3Igc3R5bGUob2JqZWN0LCBzdHJpbmcpLCB0aGUgb2JqZWN0IHNwZWNpZmllcyB0aGVcbiAgICAvLyBuYW1lcyBhbmQgdmFsdWVzIG9mIHRoZSBhdHRyaWJ1dGVzIHRvIHNldCBvciByZW1vdmUuIFRoZSB2YWx1ZXMgbWF5IGJlXG4gICAgLy8gZnVuY3Rpb25zIHRoYXQgYXJlIGV2YWx1YXRlZCBmb3IgZWFjaCBlbGVtZW50LiBUaGUgb3B0aW9uYWwgc3RyaW5nXG4gICAgLy8gc3BlY2lmaWVzIHRoZSBwcmlvcml0eS5cbiAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChuIDwgMikgdmFsdWUgPSBcIlwiO1xuICAgICAgZm9yIChwcmlvcml0eSBpbiBuYW1lKSB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX3N0eWxlKHByaW9yaXR5LCBuYW1lW3ByaW9yaXR5XSwgdmFsdWUpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEZvciBzdHlsZShzdHJpbmcpLCByZXR1cm4gdGhlIGNvbXB1dGVkIHN0eWxlIHZhbHVlIGZvciB0aGUgZmlyc3Qgbm9kZS5cbiAgICBpZiAobiA8IDIpIHJldHVybiBkM193aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLm5vZGUoKSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcblxuICAgIC8vIEZvciBzdHlsZShzdHJpbmcsIHN0cmluZykgb3Igc3R5bGUoc3RyaW5nLCBmdW5jdGlvbiksIHVzZSB0aGUgZGVmYXVsdFxuICAgIC8vIHByaW9yaXR5LiBUaGUgcHJpb3JpdHkgaXMgaWdub3JlZCBmb3Igc3R5bGUoc3RyaW5nLCBudWxsKS5cbiAgICBwcmlvcml0eSA9IFwiXCI7XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGEgbmFtZSwgdmFsdWUgYW5kIHByaW9yaXR5IGFyZSBzcGVjaWZpZWQsIGFuZCBoYW5kbGVkIGFzIGJlbG93LlxuICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9zdHlsZShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpKTtcbn07XG5cbmZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9zdHlsZShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcblxuICAvLyBGb3Igc3R5bGUobmFtZSwgbnVsbCkgb3Igc3R5bGUobmFtZSwgbnVsbCwgcHJpb3JpdHkpLCByZW1vdmUgdGhlIHN0eWxlXG4gIC8vIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLiBUaGUgcHJpb3JpdHkgaXMgaWdub3JlZC5cbiAgZnVuY3Rpb24gc3R5bGVOdWxsKCkge1xuICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gIH1cblxuICAvLyBGb3Igc3R5bGUobmFtZSwgc3RyaW5nKSBvciBzdHlsZShuYW1lLCBzdHJpbmcsIHByaW9yaXR5KSwgc2V0IHRoZSBzdHlsZVxuICAvLyBwcm9wZXJ0eSB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBwcmlvcml0eS5cbiAgZnVuY3Rpb24gc3R5bGVDb25zdGFudCgpIHtcbiAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlLCBwcmlvcml0eSk7XG4gIH1cblxuICAvLyBGb3Igc3R5bGUobmFtZSwgZnVuY3Rpb24pIG9yIHN0eWxlKG5hbWUsIGZ1bmN0aW9uLCBwcmlvcml0eSksIGV2YWx1YXRlIHRoZVxuICAvLyBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50LCBhbmQgc2V0IG9yIHJlbW92ZSB0aGUgc3R5bGUgcHJvcGVydHkgYXNcbiAgLy8gYXBwcm9wcmlhdGUuIFdoZW4gc2V0dGluZywgdXNlIHRoZSBzcGVjaWZpZWQgcHJpb3JpdHkuXG4gIGZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh4ID09IG51bGwpIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgZWxzZSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHgsIHByaW9yaXR5KTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZSA9PSBudWxsXG4gICAgICA/IHN0eWxlTnVsbCA6ICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBzdHlsZUZ1bmN0aW9uIDogc3R5bGVDb25zdGFudCk7XG59XG5cbmQzX3NlbGVjdGlvblByb3RvdHlwZS5wcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuXG4gICAgLy8gRm9yIHByb3BlcnR5KHN0cmluZyksIHJldHVybiB0aGUgcHJvcGVydHkgdmFsdWUgZm9yIHRoZSBmaXJzdCBub2RlLlxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHRoaXMubm9kZSgpW25hbWVdO1xuXG4gICAgLy8gRm9yIHByb3BlcnR5KG9iamVjdCksIHRoZSBvYmplY3Qgc3BlY2lmaWVzIHRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIHRoZVxuICAgIC8vIHByb3BlcnRpZXMgdG8gc2V0IG9yIHJlbW92ZS4gVGhlIHZhbHVlcyBtYXkgYmUgZnVuY3Rpb25zIHRoYXQgYXJlXG4gICAgLy8gZXZhbHVhdGVkIGZvciBlYWNoIGVsZW1lbnQuXG4gICAgZm9yICh2YWx1ZSBpbiBuYW1lKSB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX3Byb3BlcnR5KHZhbHVlLCBuYW1lW3ZhbHVlXSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBib3RoIGEgbmFtZSBhbmQgYSB2YWx1ZSBhcmUgc3BlY2lmaWVkLCBhbmQgYXJlIGhhbmRsZWQgYXMgYmVsb3cuXG4gIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX3Byb3BlcnR5KG5hbWUsIHZhbHVlKSk7XG59O1xuXG5mdW5jdGlvbiBkM19zZWxlY3Rpb25fcHJvcGVydHkobmFtZSwgdmFsdWUpIHtcblxuICAvLyBGb3IgcHJvcGVydHkobmFtZSwgbnVsbCksIHJlbW92ZSB0aGUgcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gIGZ1bmN0aW9uIHByb3BlcnR5TnVsbCgpIHtcbiAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgfVxuXG4gIC8vIEZvciBwcm9wZXJ0eShuYW1lLCBzdHJpbmcpLCBzZXQgdGhlIHByb3BlcnR5IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxuICBmdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KCkge1xuICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8vIEZvciBwcm9wZXJ0eShuYW1lLCBmdW5jdGlvbiksIGV2YWx1YXRlIHRoZSBmdW5jdGlvbiBmb3IgZWFjaCBlbGVtZW50LCBhbmRcbiAgLy8gc2V0IG9yIHJlbW92ZSB0aGUgcHJvcGVydHkgYXMgYXBwcm9wcmlhdGUuXG4gIGZ1bmN0aW9uIHByb3BlcnR5RnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh4ID09IG51bGwpIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgIGVsc2UgdGhpc1tuYW1lXSA9IHg7XG4gIH1cblxuICByZXR1cm4gdmFsdWUgPT0gbnVsbFxuICAgICAgPyBwcm9wZXJ0eU51bGwgOiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gcHJvcGVydHlGdW5jdGlvbiA6IHByb3BlcnR5Q29uc3RhbnQpO1xufVxuXG5kM19zZWxlY3Rpb25Qcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBmdW5jdGlvbigpIHsgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB0aGlzLnRleHRDb250ZW50ID0gdiA9PSBudWxsID8gXCJcIiA6IHY7IH0gOiB2YWx1ZSA9PSBudWxsXG4gICAgICA/IGZ1bmN0aW9uKCkgeyB0aGlzLnRleHRDb250ZW50ID0gXCJcIjsgfVxuICAgICAgOiBmdW5jdGlvbigpIHsgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlOyB9KVxuICAgICAgOiB0aGlzLm5vZGUoKS50ZXh0Q29udGVudDtcbn07XG5cbmQzX3NlbGVjdGlvblByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IGZ1bmN0aW9uKCkgeyB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IHRoaXMuaW5uZXJIVE1MID0gdiA9PSBudWxsID8gXCJcIiA6IHY7IH0gOiB2YWx1ZSA9PSBudWxsXG4gICAgICA/IGZ1bmN0aW9uKCkgeyB0aGlzLmlubmVySFRNTCA9IFwiXCI7IH1cbiAgICAgIDogZnVuY3Rpb24oKSB7IHRoaXMuaW5uZXJIVE1MID0gdmFsdWU7IH0pXG4gICAgICA6IHRoaXMubm9kZSgpLmlubmVySFRNTDtcbn07XG5cbmQzX3NlbGVjdGlvblByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIG5hbWUgPSBkM19zZWxlY3Rpb25fY3JlYXRvcihuYW1lKTtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKG5hbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2NyZWF0b3IobmFtZSkge1xuICByZXR1cm4gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWVcbiAgICAgIDogKG5hbWUgPSBkMy5ucy5xdWFsaWZ5KG5hbWUpKS5sb2NhbCA/IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKTsgfVxuICAgICAgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5uYW1lc3BhY2VVUkksIG5hbWUpOyB9O1xufVxuXG5kM19zZWxlY3Rpb25Qcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24obmFtZSwgYmVmb3JlKSB7XG4gIG5hbWUgPSBkM19zZWxlY3Rpb25fY3JlYXRvcihuYW1lKTtcbiAgYmVmb3JlID0gZDNfc2VsZWN0aW9uX3NlbGVjdG9yKGJlZm9yZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUobmFtZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBiZWZvcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCBudWxsKTtcbiAgfSk7XG59O1xuXG4vLyBUT0RPIHJlbW92ZShzZWxlY3Rvcik/XG4vLyBUT0RPIHJlbW92ZShub2RlKT9cbi8vIFRPRE8gcmVtb3ZlKGZ1bmN0aW9uKT9cbmQzX3NlbGVjdGlvblByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gZDNfY2xhc3MoY3RvciwgcHJvcGVydGllcykge1xuICB0cnkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3Rvci5wcm90b3R5cGUsIGtleSwge1xuICAgICAgICB2YWx1ZTogcHJvcGVydGllc1trZXldLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBwcm9wZXJ0aWVzO1xuICB9XG59XG5cbmQzLm1hcCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgbWFwID0gbmV3IGQzX01hcDtcbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIGQzX01hcCkgb2JqZWN0LmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkgeyBtYXAuc2V0KGtleSwgdmFsdWUpOyB9KTtcbiAgZWxzZSBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBtYXAuc2V0KGtleSwgb2JqZWN0W2tleV0pO1xuICByZXR1cm4gbWFwO1xufTtcblxuZnVuY3Rpb24gZDNfTWFwKCkge31cblxuZDNfY2xhc3MoZDNfTWFwLCB7XG4gIGhhczogZDNfbWFwX2hhcyxcbiAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gdGhpc1tkM19tYXBfcHJlZml4ICsga2V5XTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXNbZDNfbWFwX3ByZWZpeCArIGtleV0gPSB2YWx1ZTtcbiAgfSxcbiAgcmVtb3ZlOiBkM19tYXBfcmVtb3ZlLFxuICBrZXlzOiBkM19tYXBfa2V5cyxcbiAgdmFsdWVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsgdmFsdWVzLnB1c2godmFsdWUpOyB9KTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9LFxuICBlbnRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbihrZXksIHZhbHVlKSB7IGVudHJpZXMucHVzaCh7a2V5OiBrZXksIHZhbHVlOiB2YWx1ZX0pOyB9KTtcbiAgICByZXR1cm4gZW50cmllcztcbiAgfSxcbiAgc2l6ZTogZDNfbWFwX3NpemUsXG4gIGVtcHR5OiBkM19tYXBfZW1wdHksXG4gIGZvckVhY2g6IGZ1bmN0aW9uKGYpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcykgaWYgKGtleS5jaGFyQ29kZUF0KDApID09PSBkM19tYXBfcHJlZml4Q29kZSkgZi5jYWxsKHRoaXMsIGtleS5zdWJzdHJpbmcoMSksIHRoaXNba2V5XSk7XG4gIH1cbn0pO1xuXG52YXIgZDNfbWFwX3ByZWZpeCA9IFwiXFwwXCIsIC8vIHByZXZlbnQgY29sbGlzaW9uIHdpdGggYnVpbHQtaW5zXG4gICAgZDNfbWFwX3ByZWZpeENvZGUgPSBkM19tYXBfcHJlZml4LmNoYXJDb2RlQXQoMCk7XG5cbmZ1bmN0aW9uIGQzX21hcF9oYXMoa2V5KSB7XG4gIHJldHVybiBkM19tYXBfcHJlZml4ICsga2V5IGluIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGQzX21hcF9yZW1vdmUoa2V5KSB7XG4gIGtleSA9IGQzX21hcF9wcmVmaXggKyBrZXk7XG4gIHJldHVybiBrZXkgaW4gdGhpcyAmJiBkZWxldGUgdGhpc1trZXldO1xufVxuXG5mdW5jdGlvbiBkM19tYXBfa2V5cygpIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkgeyBrZXlzLnB1c2goa2V5KTsgfSk7XG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBkM19tYXBfc2l6ZSgpIHtcbiAgdmFyIHNpemUgPSAwO1xuICBmb3IgKHZhciBrZXkgaW4gdGhpcykgaWYgKGtleS5jaGFyQ29kZUF0KDApID09PSBkM19tYXBfcHJlZml4Q29kZSkgKytzaXplO1xuICByZXR1cm4gc2l6ZTtcbn1cblxuZnVuY3Rpb24gZDNfbWFwX2VtcHR5KCkge1xuICBmb3IgKHZhciBrZXkgaW4gdGhpcykgaWYgKGtleS5jaGFyQ29kZUF0KDApID09PSBkM19tYXBfcHJlZml4Q29kZSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZDNfc2VsZWN0aW9uUHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gdGhpcy5sZW5ndGgsXG4gICAgICBncm91cCxcbiAgICAgIG5vZGU7XG5cbiAgLy8gSWYgbm8gdmFsdWUgaXMgc3BlY2lmaWVkLCByZXR1cm4gdGhlIGZpcnN0IHZhbHVlLlxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB2YWx1ZSA9IG5ldyBBcnJheShuID0gKGdyb3VwID0gdGhpc1swXSkubGVuZ3RoKTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICB2YWx1ZVtpXSA9IG5vZGUuX19kYXRhX187XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmQoZ3JvdXAsIGdyb3VwRGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICBtID0gZ3JvdXBEYXRhLmxlbmd0aCxcbiAgICAgICAgbjAgPSBNYXRoLm1pbihuLCBtKSxcbiAgICAgICAgdXBkYXRlTm9kZXMgPSBuZXcgQXJyYXkobSksXG4gICAgICAgIGVudGVyTm9kZXMgPSBuZXcgQXJyYXkobSksXG4gICAgICAgIGV4aXROb2RlcyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbm9kZURhdGE7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICB2YXIgbm9kZUJ5S2V5VmFsdWUgPSBuZXcgZDNfTWFwLFxuICAgICAgICAgIGRhdGFCeUtleVZhbHVlID0gbmV3IGQzX01hcCxcbiAgICAgICAgICBrZXlWYWx1ZXMgPSBbXSxcbiAgICAgICAgICBrZXlWYWx1ZTtcblxuICAgICAgZm9yIChpID0gLTE7ICsraSA8IG47KSB7XG4gICAgICAgIGtleVZhbHVlID0ga2V5LmNhbGwobm9kZSA9IGdyb3VwW2ldLCBub2RlLl9fZGF0YV9fLCBpKTtcbiAgICAgICAgaWYgKG5vZGVCeUtleVZhbHVlLmhhcyhrZXlWYWx1ZSkpIHtcbiAgICAgICAgICBleGl0Tm9kZXNbaV0gPSBub2RlOyAvLyBkdXBsaWNhdGUgc2VsZWN0aW9uIGtleVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGVCeUtleVZhbHVlLnNldChrZXlWYWx1ZSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAga2V5VmFsdWVzLnB1c2goa2V5VmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAtMTsgKytpIDwgbTspIHtcbiAgICAgICAga2V5VmFsdWUgPSBrZXkuY2FsbChncm91cERhdGEsIG5vZGVEYXRhID0gZ3JvdXBEYXRhW2ldLCBpKTtcbiAgICAgICAgaWYgKG5vZGUgPSBub2RlQnlLZXlWYWx1ZS5nZXQoa2V5VmFsdWUpKSB7XG4gICAgICAgICAgdXBkYXRlTm9kZXNbaV0gPSBub2RlO1xuICAgICAgICAgIG5vZGUuX19kYXRhX18gPSBub2RlRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmICghZGF0YUJ5S2V5VmFsdWUuaGFzKGtleVZhbHVlKSkgeyAvLyBubyBkdXBsaWNhdGUgZGF0YSBrZXlcbiAgICAgICAgICBlbnRlck5vZGVzW2ldID0gZDNfc2VsZWN0aW9uX2RhdGFOb2RlKG5vZGVEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhQnlLZXlWYWx1ZS5zZXQoa2V5VmFsdWUsIG5vZGVEYXRhKTtcbiAgICAgICAgbm9kZUJ5S2V5VmFsdWUucmVtb3ZlKGtleVZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gLTE7ICsraSA8IG47KSB7XG4gICAgICAgIGlmIChub2RlQnlLZXlWYWx1ZS5oYXMoa2V5VmFsdWVzW2ldKSkge1xuICAgICAgICAgIGV4aXROb2Rlc1tpXSA9IGdyb3VwW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IC0xOyArK2kgPCBuMDspIHtcbiAgICAgICAgbm9kZSA9IGdyb3VwW2ldO1xuICAgICAgICBub2RlRGF0YSA9IGdyb3VwRGF0YVtpXTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICBub2RlLl9fZGF0YV9fID0gbm9kZURhdGE7XG4gICAgICAgICAgdXBkYXRlTm9kZXNbaV0gPSBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVudGVyTm9kZXNbaV0gPSBkM19zZWxlY3Rpb25fZGF0YU5vZGUobm9kZURhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IG07ICsraSkge1xuICAgICAgICBlbnRlck5vZGVzW2ldID0gZDNfc2VsZWN0aW9uX2RhdGFOb2RlKGdyb3VwRGF0YVtpXSk7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgICBleGl0Tm9kZXNbaV0gPSBncm91cFtpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbnRlck5vZGVzLnVwZGF0ZVxuICAgICAgICA9IHVwZGF0ZU5vZGVzO1xuXG4gICAgZW50ZXJOb2Rlcy5wYXJlbnROb2RlXG4gICAgICAgID0gdXBkYXRlTm9kZXMucGFyZW50Tm9kZVxuICAgICAgICA9IGV4aXROb2Rlcy5wYXJlbnROb2RlXG4gICAgICAgID0gZ3JvdXAucGFyZW50Tm9kZTtcblxuICAgIGVudGVyLnB1c2goZW50ZXJOb2Rlcyk7XG4gICAgdXBkYXRlLnB1c2godXBkYXRlTm9kZXMpO1xuICAgIGV4aXQucHVzaChleGl0Tm9kZXMpO1xuICB9XG5cbiAgdmFyIGVudGVyID0gZDNfc2VsZWN0aW9uX2VudGVyKFtdKSxcbiAgICAgIHVwZGF0ZSA9IGQzX3NlbGVjdGlvbihbXSksXG4gICAgICBleGl0ID0gZDNfc2VsZWN0aW9uKFtdKTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgYmluZChncm91cCA9IHRoaXNbaV0sIHZhbHVlLmNhbGwoZ3JvdXAsIGdyb3VwLnBhcmVudE5vZGUuX19kYXRhX18sIGkpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGJpbmQoZ3JvdXAgPSB0aGlzW2ldLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlLmVudGVyID0gZnVuY3Rpb24oKSB7IHJldHVybiBlbnRlcjsgfTtcbiAgdXBkYXRlLmV4aXQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGV4aXQ7IH07XG4gIHJldHVybiB1cGRhdGU7XG59O1xuXG5mdW5jdGlvbiBkM19zZWxlY3Rpb25fZGF0YU5vZGUoZGF0YSkge1xuICByZXR1cm4ge19fZGF0YV9fOiBkYXRhfTtcbn1cblxuZDNfc2VsZWN0aW9uUHJvdG90eXBlLmRhdHVtID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5wcm9wZXJ0eShcIl9fZGF0YV9fXCIsIHZhbHVlKVxuICAgICAgOiB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIik7XG59O1xuXG5kM19zZWxlY3Rpb25Qcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gIHZhciBzdWJncm91cHMgPSBbXSxcbiAgICAgIHN1Ymdyb3VwLFxuICAgICAgZ3JvdXAsXG4gICAgICBub2RlO1xuXG4gIGlmICh0eXBlb2YgZmlsdGVyICE9PSBcImZ1bmN0aW9uXCIpIGZpbHRlciA9IGQzX3NlbGVjdGlvbl9maWx0ZXIoZmlsdGVyKTtcblxuICBmb3IgKHZhciBqID0gMCwgbSA9IHRoaXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgc3ViZ3JvdXAucGFyZW50Tm9kZSA9IChncm91cCA9IHRoaXNbal0pLnBhcmVudE5vZGU7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiBmaWx0ZXIuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSkge1xuICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkM19zZWxlY3Rpb24oc3ViZ3JvdXBzKTtcbn07XG5cbmZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9maWx0ZXIoc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zZWxlY3RNYXRjaGVzKHRoaXMsIHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuZDNfc2VsZWN0aW9uUHJvdG90eXBlLm9yZGVyID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOykge1xuICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IGdyb3VwLmxlbmd0aCAtIDEsIG5leHQgPSBncm91cFtpXSwgbm9kZTsgLS1pID49IDA7KSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09IG5vZGUubmV4dFNpYmxpbmcpIG5leHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCk7XG4gICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5kMy5hc2NlbmRpbmcgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbn07XG5cbmQzX3NlbGVjdGlvblByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICBjb21wYXJhdG9yID0gZDNfc2VsZWN0aW9uX3NvcnRDb21wYXJhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOykgdGhpc1tqXS5zb3J0KGNvbXBhcmF0b3IpO1xuICByZXR1cm4gdGhpcy5vcmRlcigpO1xufTtcblxuZnVuY3Rpb24gZDNfc2VsZWN0aW9uX3NvcnRDb21wYXJhdG9yKGNvbXBhcmF0b3IpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSBjb21wYXJhdG9yID0gZDMuYXNjZW5kaW5nO1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhICYmIGIgPyBjb21wYXJhdG9yKGEuX19kYXRhX18sIGIuX19kYXRhX18pIDogIWEgLSAhYjtcbiAgfTtcbn1cbmZ1bmN0aW9uIGQzX25vb3AoKSB7fVxuXG5kMy5kaXNwYXRjaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGlzcGF0Y2ggPSBuZXcgZDNfZGlzcGF0Y2gsXG4gICAgICBpID0gLTEsXG4gICAgICBuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIGRpc3BhdGNoW2FyZ3VtZW50c1tpXV0gPSBkM19kaXNwYXRjaF9ldmVudChkaXNwYXRjaCk7XG4gIHJldHVybiBkaXNwYXRjaDtcbn07XG5cbmZ1bmN0aW9uIGQzX2Rpc3BhdGNoKCkge31cblxuZDNfZGlzcGF0Y2gucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGkgPSB0eXBlLmluZGV4T2YoXCIuXCIpLFxuICAgICAgbmFtZSA9IFwiXCI7XG5cbiAgLy8gRXh0cmFjdCBvcHRpb25hbCBuYW1lc3BhY2UsIGUuZy4sIFwiY2xpY2suZm9vXCJcbiAgaWYgKGkgPj0gMCkge1xuICAgIG5hbWUgPSB0eXBlLnN1YnN0cmluZyhpICsgMSk7XG4gICAgdHlwZSA9IHR5cGUuc3Vic3RyaW5nKDAsIGkpO1xuICB9XG5cbiAgaWYgKHR5cGUpIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMlxuICAgICAgPyB0aGlzW3R5cGVdLm9uKG5hbWUpXG4gICAgICA6IHRoaXNbdHlwZV0ub24obmFtZSwgbGlzdGVuZXIpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKGxpc3RlbmVyID09IG51bGwpIGZvciAodHlwZSBpbiB0aGlzKSB7XG4gICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhpc1t0eXBlXS5vbihuYW1lLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGQzX2Rpc3BhdGNoX2V2ZW50KGRpc3BhdGNoKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXSxcbiAgICAgIGxpc3RlbmVyQnlOYW1lID0gbmV3IGQzX01hcDtcblxuICBmdW5jdGlvbiBldmVudCgpIHtcbiAgICB2YXIgeiA9IGxpc3RlbmVycywgLy8gZGVmZW5zaXZlIHJlZmVyZW5jZVxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSB6Lmxlbmd0aCxcbiAgICAgICAgbDtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKGwgPSB6W2ldLm9uKSBsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGRpc3BhdGNoO1xuICB9XG5cbiAgZXZlbnQub24gPSBmdW5jdGlvbihuYW1lLCBsaXN0ZW5lcikge1xuICAgIHZhciBsID0gbGlzdGVuZXJCeU5hbWUuZ2V0KG5hbWUpLFxuICAgICAgICBpO1xuXG4gICAgLy8gcmV0dXJuIHRoZSBjdXJyZW50IGxpc3RlbmVyLCBpZiBhbnlcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiBsICYmIGwub247XG5cbiAgICAvLyByZW1vdmUgdGhlIG9sZCBsaXN0ZW5lciwgaWYgYW55ICh3aXRoIGNvcHktb24td3JpdGUpXG4gICAgaWYgKGwpIHtcbiAgICAgIGwub24gPSBudWxsO1xuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLnNsaWNlKDAsIGkgPSBsaXN0ZW5lcnMuaW5kZXhPZihsKSkuY29uY2F0KGxpc3RlbmVycy5zbGljZShpICsgMSkpO1xuICAgICAgbGlzdGVuZXJCeU5hbWUucmVtb3ZlKG5hbWUpO1xuICAgIH1cblxuICAgIC8vIGFkZCB0aGUgbmV3IGxpc3RlbmVyLCBpZiBhbnlcbiAgICBpZiAobGlzdGVuZXIpIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyQnlOYW1lLnNldChuYW1lLCB7b246IGxpc3RlbmVyfSkpO1xuXG4gICAgcmV0dXJuIGRpc3BhdGNoO1xuICB9O1xuXG4gIHJldHVybiBldmVudDtcbn1cblxuZDMuZXZlbnQgPSBudWxsO1xuXG5mdW5jdGlvbiBkM19ldmVudFByZXZlbnREZWZhdWx0KCkge1xuICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5mdW5jdGlvbiBkM19ldmVudFNvdXJjZSgpIHtcbiAgdmFyIGUgPSBkMy5ldmVudCwgcztcbiAgd2hpbGUgKHMgPSBlLnNvdXJjZUV2ZW50KSBlID0gcztcbiAgcmV0dXJuIGU7XG59XG5cbi8vIExpa2UgZDMuZGlzcGF0Y2gsIGJ1dCBmb3IgY3VzdG9tIGV2ZW50cyBhYnN0cmFjdGluZyBuYXRpdmUgVUkgZXZlbnRzLiBUaGVzZVxuLy8gZXZlbnRzIGhhdmUgYSB0YXJnZXQgY29tcG9uZW50IChzdWNoIGFzIGEgYnJ1c2gpLCBhIHRhcmdldCBlbGVtZW50IChzdWNoIGFzXG4vLyB0aGUgc3ZnOmcgZWxlbWVudCBjb250YWluaW5nIHRoZSBicnVzaCkgYW5kIHRoZSBzdGFuZGFyZCBhcmd1bWVudHMgYGRgICh0aGVcbi8vIHRhcmdldCBlbGVtZW50J3MgZGF0YSkgYW5kIGBpYCAodGhlIHNlbGVjdGlvbiBpbmRleCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQpLlxuZnVuY3Rpb24gZDNfZXZlbnREaXNwYXRjaCh0YXJnZXQpIHtcbiAgdmFyIGRpc3BhdGNoID0gbmV3IGQzX2Rpc3BhdGNoLFxuICAgICAgaSA9IDAsXG4gICAgICBuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpIDwgbikgZGlzcGF0Y2hbYXJndW1lbnRzW2ldXSA9IGQzX2Rpc3BhdGNoX2V2ZW50KGRpc3BhdGNoKTtcblxuICAvLyBDcmVhdGVzIGEgZGlzcGF0Y2ggY29udGV4dCBmb3IgdGhlIHNwZWNpZmllZCBgdGhpemAgKHR5cGljYWxseSwgdGhlIHRhcmdldFxuICAvLyBET00gZWxlbWVudCB0aGF0IHJlY2VpdmVkIHRoZSBzb3VyY2UgZXZlbnQpIGFuZCBgYXJndW1lbnR6YCAodHlwaWNhbGx5LCB0aGVcbiAgLy8gZGF0YSBgZGAgYW5kIGluZGV4IGBpYCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQpLiBUaGUgcmV0dXJuZWQgZnVuY3Rpb24gY2FuIGJlXG4gIC8vIHVzZWQgdG8gZGlzcGF0Y2ggYW4gZXZlbnQgdG8gYW55IHJlZ2lzdGVyZWQgbGlzdGVuZXJzOyB0aGUgZnVuY3Rpb24gdGFrZXMgYVxuICAvLyBzaW5nbGUgYXJndW1lbnQgYXMgaW5wdXQsIGJlaW5nIHRoZSBldmVudCB0byBkaXNwYXRjaC4gVGhlIGV2ZW50IG11c3QgaGF2ZVxuICAvLyBhIFwidHlwZVwiIGF0dHJpYnV0ZSB3aGljaCBjb3JyZXNwb25kcyB0byBhIHR5cGUgcmVnaXN0ZXJlZCBpbiB0aGVcbiAgLy8gY29uc3RydWN0b3IuIFRoaXMgY29udGV4dCB3aWxsIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGUgdGhlIFwic291cmNlRXZlbnRcIiBhbmRcbiAgLy8gXCJ0YXJnZXRcIiBhdHRyaWJ1dGVzIG9mIHRoZSBldmVudCwgYXMgd2VsbCBhcyBzZXR0aW5nIHRoZSBgZDMuZXZlbnRgIGdsb2JhbFxuICAvLyBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBub3RpZmljYXRpb24uXG4gIGRpc3BhdGNoLm9mID0gZnVuY3Rpb24odGhpeiwgYXJndW1lbnR6KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUxKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZTAgPVxuICAgICAgICBlMS5zb3VyY2VFdmVudCA9IGQzLmV2ZW50O1xuICAgICAgICBlMS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIGQzLmV2ZW50ID0gZTE7XG4gICAgICAgIGRpc3BhdGNoW2UxLnR5cGVdLmFwcGx5KHRoaXosIGFyZ3VtZW50eik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkMy5ldmVudCA9IGUwO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIGRpc3BhdGNoO1xufVxuXG5kM19zZWxlY3Rpb25Qcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSkge1xuICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmIChuIDwgMykge1xuXG4gICAgLy8gRm9yIG9uKG9iamVjdCkgb3Igb24ob2JqZWN0LCBib29sZWFuKSwgdGhlIG9iamVjdCBzcGVjaWZpZXMgdGhlIGV2ZW50XG4gICAgLy8gdHlwZXMgYW5kIGxpc3RlbmVycyB0byBhZGQgb3IgcmVtb3ZlLiBUaGUgb3B0aW9uYWwgYm9vbGVhbiBzcGVjaWZpZXNcbiAgICAvLyB3aGV0aGVyIHRoZSBsaXN0ZW5lciBjYXB0dXJlcyBldmVudHMuXG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAobiA8IDIpIGxpc3RlbmVyID0gZmFsc2U7XG4gICAgICBmb3IgKGNhcHR1cmUgaW4gdHlwZSkgdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9vbihjYXB0dXJlLCB0eXBlW2NhcHR1cmVdLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRm9yIG9uKHN0cmluZyksIHJldHVybiB0aGUgbGlzdGVuZXIgZm9yIHRoZSBmaXJzdCBub2RlLlxuICAgIGlmIChuIDwgMikgcmV0dXJuIChuID0gdGhpcy5ub2RlKClbXCJfX29uXCIgKyB0eXBlXSkgJiYgbi5fO1xuXG4gICAgLy8gRm9yIG9uKHN0cmluZywgZnVuY3Rpb24pLCB1c2UgdGhlIGRlZmF1bHQgY2FwdHVyZS5cbiAgICBjYXB0dXJlID0gZmFsc2U7XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGEgdHlwZSwgbGlzdGVuZXIgYW5kIGNhcHR1cmUgYXJlIHNwZWNpZmllZCwgYW5kIGhhbmRsZWQgYXMgYmVsb3cuXG4gIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX29uKHR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKSk7XG59O1xuXG5mdW5jdGlvbiBkM19zZWxlY3Rpb25fb24odHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpIHtcbiAgdmFyIG5hbWUgPSBcIl9fb25cIiArIHR5cGUsXG4gICAgICBpID0gdHlwZS5pbmRleE9mKFwiLlwiKSxcbiAgICAgIHdyYXAgPSBkM19zZWxlY3Rpb25fb25MaXN0ZW5lcjtcblxuICBpZiAoaSA+IDApIHR5cGUgPSB0eXBlLnN1YnN0cmluZygwLCBpKTtcbiAgdmFyIGZpbHRlciA9IGQzX3NlbGVjdGlvbl9vbkZpbHRlcnMuZ2V0KHR5cGUpO1xuICBpZiAoZmlsdGVyKSB0eXBlID0gZmlsdGVyLCB3cmFwID0gZDNfc2VsZWN0aW9uX29uRmlsdGVyO1xuXG4gIGZ1bmN0aW9uIG9uUmVtb3ZlKCkge1xuICAgIHZhciBsID0gdGhpc1tuYW1lXTtcbiAgICBpZiAobCkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGwsIGwuJCk7XG4gICAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkFkZCgpIHtcbiAgICB2YXIgbCA9IHdyYXAobGlzdGVuZXIsIGQzX2FycmF5KGFyZ3VtZW50cykpO1xuICAgIG9uUmVtb3ZlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXNbbmFtZV0gPSBsLCBsLiQgPSBjYXB0dXJlKTtcbiAgICBsLl8gPSBsaXN0ZW5lcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFsbCgpIHtcbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiXl9fb24oW14uXSspXCIgKyBkMy5yZXF1b3RlKHR5cGUpICsgXCIkXCIpLFxuICAgICAgICBtYXRjaDtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgIGlmIChtYXRjaCA9IG5hbWUubWF0Y2gocmUpKSB7XG4gICAgICAgIHZhciBsID0gdGhpc1tuYW1lXTtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG1hdGNoWzFdLCBsLCBsLiQpO1xuICAgICAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaVxuICAgICAgPyBsaXN0ZW5lciA/IG9uQWRkIDogb25SZW1vdmVcbiAgICAgIDogbGlzdGVuZXIgPyBkM19ub29wIDogcmVtb3ZlQWxsO1xufVxuXG52YXIgZDNfc2VsZWN0aW9uX29uRmlsdGVycyA9IGQzLm1hcCh7XG4gIG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG4gIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIlxufSk7XG5cbmQzX3NlbGVjdGlvbl9vbkZpbHRlcnMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gIGlmIChcIm9uXCIgKyBrIGluIGQzX2RvY3VtZW50KSBkM19zZWxlY3Rpb25fb25GaWx0ZXJzLnJlbW92ZShrKTtcbn0pO1xuXG5mdW5jdGlvbiBkM19zZWxlY3Rpb25fb25MaXN0ZW5lcihsaXN0ZW5lciwgYXJndW1lbnR6KSB7XG4gIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIG8gPSBkMy5ldmVudDsgLy8gRXZlbnRzIGNhbiBiZSByZWVudHJhbnQgKGUuZy4sIGZvY3VzKS5cbiAgICBkMy5ldmVudCA9IGU7XG4gICAgYXJndW1lbnR6WzBdID0gdGhpcy5fX2RhdGFfXztcbiAgICB0cnkge1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnR6KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZDMuZXZlbnQgPSBvO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZDNfc2VsZWN0aW9uX29uRmlsdGVyKGxpc3RlbmVyLCBhcmd1bWVudHopIHtcbiAgdmFyIGwgPSBkM19zZWxlY3Rpb25fb25MaXN0ZW5lcihsaXN0ZW5lciwgYXJndW1lbnR6KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcywgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldDtcbiAgICBpZiAoIXJlbGF0ZWQgfHwgKHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhKHJlbGF0ZWQuY29tcGFyZURvY3VtZW50UG9zaXRpb24odGFyZ2V0KSAmIDgpKSkge1xuICAgICAgbC5jYWxsKHRhcmdldCwgZSk7XG4gICAgfVxuICB9O1xufVxuXG5kM19zZWxlY3Rpb25Qcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHJldHVybiBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCBmdW5jdGlvbihub2RlLCBpLCBqKSB7XG4gICAgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkM19zZWxlY3Rpb25fZWFjaChncm91cHMsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZTsgaSA8IG47IGkrKykge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgY2FsbGJhY2sobm9kZSwgaSwgaik7XG4gICAgfVxuICB9XG4gIHJldHVybiBncm91cHM7XG59XG5cbmQzX3NlbGVjdGlvblByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIGFyZ3MgPSBkM19hcnJheShhcmd1bWVudHMpO1xuICBjYWxsYmFjay5hcHBseShhcmdzWzBdID0gdGhpcywgYXJncyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZDNfc2VsZWN0aW9uUHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhdGhpcy5ub2RlKCk7XG59O1xuXG5kM19zZWxlY3Rpb25Qcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBqID0gMCwgbSA9IHRoaXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChub2RlKSByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5kM19zZWxlY3Rpb25Qcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9IDA7XG4gIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgKytuOyB9KTtcbiAgcmV0dXJuIG47XG59O1xuXG5mdW5jdGlvbiBkM19zZWxlY3Rpb25fZW50ZXIoc2VsZWN0aW9uKSB7XG4gIGQzX3N1YmNsYXNzKHNlbGVjdGlvbiwgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlKTtcbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn1cblxudmFyIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZSA9IFtdO1xuXG5kMy5zZWxlY3Rpb24uZW50ZXIgPSBkM19zZWxlY3Rpb25fZW50ZXI7XG5kMy5zZWxlY3Rpb24uZW50ZXIucHJvdG90eXBlID0gZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlO1xuXG5kM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuYXBwZW5kID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLmFwcGVuZDtcbmQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5lbXB0eSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5lbXB0eTtcbmQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5ub2RlID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLm5vZGU7XG5kM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuY2FsbCA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5jYWxsO1xuZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLnNpemUgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc2l6ZTtcblxuXG5kM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgdmFyIHN1Ymdyb3VwcyA9IFtdLFxuICAgICAgc3ViZ3JvdXAsXG4gICAgICBzdWJub2RlLFxuICAgICAgdXBncm91cCxcbiAgICAgIGdyb3VwLFxuICAgICAgbm9kZTtcblxuICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTspIHtcbiAgICB1cGdyb3VwID0gKGdyb3VwID0gdGhpc1tqXSkudXBkYXRlO1xuICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgIHN1Ymdyb3VwLnBhcmVudE5vZGUgPSBncm91cC5wYXJlbnROb2RlO1xuICAgIGZvciAodmFyIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjspIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc3ViZ3JvdXAucHVzaCh1cGdyb3VwW2ldID0gc3Vibm9kZSA9IHNlbGVjdG9yLmNhbGwoZ3JvdXAucGFyZW50Tm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpO1xuICAgICAgICBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGQzX3NlbGVjdGlvbihzdWJncm91cHMpO1xufTtcblxuZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKG5hbWUsIGJlZm9yZSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIGJlZm9yZSA9IGQzX3NlbGVjdGlvbl9lbnRlckluc2VydEJlZm9yZSh0aGlzKTtcbiAgcmV0dXJuIGQzX3NlbGVjdGlvblByb3RvdHlwZS5pbnNlcnQuY2FsbCh0aGlzLCBuYW1lLCBiZWZvcmUpO1xufTtcblxuZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2VudGVySW5zZXJ0QmVmb3JlKGVudGVyKSB7XG4gIHZhciBpMCwgajA7XG4gIHJldHVybiBmdW5jdGlvbihkLCBpLCBqKSB7XG4gICAgdmFyIGdyb3VwID0gZW50ZXJbal0udXBkYXRlLFxuICAgICAgICBuID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICBub2RlO1xuICAgIGlmIChqICE9IGowKSBqMCA9IGosIGkwID0gMDtcbiAgICBpZiAoaSA+PSBpMCkgaTAgPSBpICsgMTtcbiAgICB3aGlsZSAoIShub2RlID0gZ3JvdXBbaTBdKSAmJiArK2kwIDwgbik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG59XG5cbi8vIGltcG9ydCBcIi4uL3RyYW5zaXRpb24vdHJhbnNpdGlvblwiO1xuXG5kM19zZWxlY3Rpb25Qcm90b3R5cGUudHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaWQgPSBkM190cmFuc2l0aW9uSW5oZXJpdElkIHx8ICsrZDNfdHJhbnNpdGlvbklkLFxuICAgICAgc3ViZ3JvdXBzID0gW10sXG4gICAgICBzdWJncm91cCxcbiAgICAgIG5vZGUsXG4gICAgICB0cmFuc2l0aW9uID0gZDNfdHJhbnNpdGlvbkluaGVyaXQgfHwge3RpbWU6IERhdGUubm93KCksIGVhc2U6IGQzX2Vhc2VfY3ViaWNJbk91dCwgZGVsYXk6IDAsIGR1cmF0aW9uOiAyNTB9O1xuXG4gIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOykge1xuICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IC0xLCBuID0gZ3JvdXAubGVuZ3RoOyArK2kgPCBuOykge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkgZDNfdHJhbnNpdGlvbk5vZGUobm9kZSwgaSwgaWQsIHRyYW5zaXRpb24pO1xuICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZDNfdHJhbnNpdGlvbihzdWJncm91cHMsIGlkKTtcbn07XG4vLyBpbXBvcnQgXCIuLi90cmFuc2l0aW9uL3RyYW5zaXRpb25cIjtcblxuZDNfc2VsZWN0aW9uUHJvdG90eXBlLmludGVycnVwdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHQpO1xufTtcblxuZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2ludGVycnVwdCgpIHtcbiAgdmFyIGxvY2sgPSB0aGlzLl9fdHJhbnNpdGlvbl9fO1xuICBpZiAobG9jaykgKytsb2NrLmFjdGl2ZTtcbn1cblxuLy8gVE9ETyBmYXN0IHNpbmdsZXRvbiBpbXBsZW1lbnRhdGlvbj9cbmQzLnNlbGVjdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIGdyb3VwID0gW3R5cGVvZiBub2RlID09PSBcInN0cmluZ1wiID8gZDNfc2VsZWN0KG5vZGUsIGQzX2RvY3VtZW50KSA6IG5vZGVdO1xuICBncm91cC5wYXJlbnROb2RlID0gZDNfZG9jdW1lbnRFbGVtZW50O1xuICByZXR1cm4gZDNfc2VsZWN0aW9uKFtncm91cF0pO1xufTtcblxuZDMuc2VsZWN0QWxsID0gZnVuY3Rpb24obm9kZXMpIHtcbiAgdmFyIGdyb3VwID0gZDNfYXJyYXkodHlwZW9mIG5vZGVzID09PSBcInN0cmluZ1wiID8gZDNfc2VsZWN0QWxsKG5vZGVzLCBkM19kb2N1bWVudCkgOiBub2Rlcyk7XG4gIGdyb3VwLnBhcmVudE5vZGUgPSBkM19kb2N1bWVudEVsZW1lbnQ7XG4gIHJldHVybiBkM19zZWxlY3Rpb24oW2dyb3VwXSk7XG59O1xuXG52YXIgZDNfc2VsZWN0aW9uUm9vdCA9IGQzLnNlbGVjdChkM19kb2N1bWVudEVsZW1lbnQpO1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZDMpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGQzO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZDMgPSBkMztcbiAgfVxufSgpO1xuIiwiZnVuY3Rpb24gY29yc2xpdGUodXJsLCBjYWxsYmFjaywgY29ycykge1xuICAgIHZhciBzZW50ID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdy5YTUxIdHRwUmVxdWVzdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9yKCdCcm93c2VyIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb3JzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgbSA9IHVybC5tYXRjaCgvXlxccypodHRwcz86XFwvXFwvW15cXC9dKi8pO1xuICAgICAgICBjb3JzID0gbSAmJiAobVswXSAhPT0gbG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgbG9jYXRpb24uaG9zdG5hbWUgK1xuICAgICAgICAgICAgICAgIChsb2NhdGlvbi5wb3J0ID8gJzonICsgbG9jYXRpb24ucG9ydCA6ICcnKSk7XG4gICAgfVxuXG4gICAgdmFyIHggPSBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICBmdW5jdGlvbiBpc1N1Y2Nlc3NmdWwoc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcbiAgICB9XG5cbiAgICBpZiAoY29ycyAmJiAhKCd3aXRoQ3JlZGVudGlhbHMnIGluIHgpKSB7XG4gICAgICAgIC8vIElFOC05XG4gICAgICAgIHggPSBuZXcgd2luZG93LlhEb21haW5SZXF1ZXN0KCk7XG5cbiAgICAgICAgLy8gRW5zdXJlIGNhbGxiYWNrIGlzIG5ldmVyIGNhbGxlZCBzeW5jaHJvbm91c2x5LCBpLmUuLCBiZWZvcmVcbiAgICAgICAgLy8geC5zZW5kKCkgcmV0dXJucyAodGhpcyBoYXMgYmVlbiBvYnNlcnZlZCBpbiB0aGUgd2lsZCkuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L21hcGJveC5qcy9pc3N1ZXMvNDcyXG4gICAgICAgIHZhciBvcmlnaW5hbCA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHNlbnQpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWwuYXBwbHkodGhhdCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkZWQoKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIFhEb21haW5SZXF1ZXN0XG4gICAgICAgICAgICB4LnN0YXR1cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAvLyBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgICAgIGlzU3VjY2Vzc2Z1bCh4LnN0YXR1cykpIGNhbGxiYWNrLmNhbGwoeCwgbnVsbCwgeCk7XG4gICAgICAgIGVsc2UgY2FsbGJhY2suY2FsbCh4LCB4LCBudWxsKTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIGBvbnJlYWR5c3RhdGVjaGFuZ2VgIGFuZCBgb25sb2FkYCBjYW4gZmlyZS4gYG9ucmVhZHlzdGF0ZWNoYW5nZWBcbiAgICAvLyBoYXMgW2JlZW4gc3VwcG9ydGVkIGZvciBsb25nZXJdKGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzkxODE1MDgvMjI5MDAxKS5cbiAgICBpZiAoJ29ubG9hZCcgaW4geCkge1xuICAgICAgICB4Lm9ubG9hZCA9IGxvYWRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB4Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIHJlYWR5c3RhdGUoKSB7XG4gICAgICAgICAgICBpZiAoeC5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgbG9hZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0IGFzIGFuIGVycm9yIGFuZCBwcmV2ZW50XG4gICAgLy8gaXQgZnJvbSBldmVyIGJlaW5nIGNhbGxlZCBhZ2FpbiBieSByZWFzc2lnbmluZyBpdCB0byBgbm9vcGBcbiAgICB4Lm9uZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihldnQpIHtcbiAgICAgICAgLy8gWERvbWFpblJlcXVlc3QgcHJvdmlkZXMgbm8gZXZ0IHBhcmFtZXRlclxuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGV2dCB8fCB0cnVlLCBudWxsKTtcbiAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHsgfTtcbiAgICB9O1xuXG4gICAgLy8gSUU5IG11c3QgaGF2ZSBvbnByb2dyZXNzIGJlIHNldCB0byBhIHVuaXF1ZSBmdW5jdGlvbi5cbiAgICB4Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHsgfTtcblxuICAgIHgub250aW1lb3V0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZXZ0LCBudWxsKTtcbiAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHsgfTtcbiAgICB9O1xuXG4gICAgeC5vbmFib3J0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgZXZ0LCBudWxsKTtcbiAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHsgfTtcbiAgICB9O1xuXG4gICAgLy8gR0VUIGlzIHRoZSBvbmx5IHN1cHBvcnRlZCBIVFRQIFZlcmIgYnkgWERvbWFpblJlcXVlc3QgYW5kIGlzIHRoZVxuICAgIC8vIG9ubHkgb25lIHN1cHBvcnRlZCBoZXJlLlxuICAgIHgub3BlbignR0VUJywgdXJsLCB0cnVlKTtcblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3QuIFNlbmRpbmcgZGF0YSBpcyBub3Qgc3VwcG9ydGVkLlxuICAgIHguc2VuZChudWxsKTtcbiAgICBzZW50ID0gdHJ1ZTtcblxuICAgIHJldHVybiB4O1xufVxuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIG1vZHVsZS5leHBvcnRzID0gY29yc2xpdGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQmFzZWQgb2ZmIG9mIFt0aGUgb2ZmaWNhbCBHb29nbGUgZG9jdW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi91dGlsaXRpZXMvcG9seWxpbmVhbGdvcml0aG0pXG4gKlxuICogU29tZSBwYXJ0cyBmcm9tIFt0aGlzIGltcGxlbWVudGF0aW9uXShodHRwOi8vZmFjc3RhZmYudW5jYS5lZHUvbWNtY2NsdXIvR29vZ2xlTWFwcy9FbmNvZGVQb2x5bGluZS9Qb2x5bGluZUVuY29kZXIuanMpXG4gKiBieSBbTWFyayBNY0NsdXJlXShodHRwOi8vZmFjc3RhZmYudW5jYS5lZHUvbWNtY2NsdXIvKVxuICpcbiAqIEBtb2R1bGUgcG9seWxpbmVcbiAqL1xuXG52YXIgcG9seWxpbmUgPSB7fTtcblxuZnVuY3Rpb24gcHkyX3JvdW5kKHZhbHVlKSB7XG4gICAgLy8gR29vZ2xlJ3MgcG9seWxpbmUgYWxnb3JpdGhtIHVzZXMgdGhlIHNhbWUgcm91bmRpbmcgc3RyYXRlZ3kgYXMgUHl0aG9uIDIsIHdoaWNoIGlzIGRpZmZlcmVudCBmcm9tIEpTIGZvciBuZWdhdGl2ZSB2YWx1ZXNcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmFicyh2YWx1ZSkgKyAwLjUpICogTWF0aC5zaWduKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlKGN1cnJlbnQsIHByZXZpb3VzLCBmYWN0b3IpIHtcbiAgICBjdXJyZW50ID0gcHkyX3JvdW5kKGN1cnJlbnQgKiBmYWN0b3IpO1xuICAgIHByZXZpb3VzID0gcHkyX3JvdW5kKHByZXZpb3VzICogZmFjdG9yKTtcbiAgICB2YXIgY29vcmRpbmF0ZSA9IGN1cnJlbnQgLSBwcmV2aW91cztcbiAgICBjb29yZGluYXRlIDw8PSAxO1xuICAgIGlmIChjdXJyZW50IC0gcHJldmlvdXMgPCAwKSB7XG4gICAgICAgIGNvb3JkaW5hdGUgPSB+Y29vcmRpbmF0ZTtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9ICcnO1xuICAgIHdoaWxlIChjb29yZGluYXRlID49IDB4MjApIHtcbiAgICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKDB4MjAgfCAoY29vcmRpbmF0ZSAmIDB4MWYpKSArIDYzKTtcbiAgICAgICAgY29vcmRpbmF0ZSA+Pj0gNTtcbiAgICB9XG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29vcmRpbmF0ZSArIDYzKTtcbiAgICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIERlY29kZXMgdG8gYSBbbGF0aXR1ZGUsIGxvbmdpdHVkZV0gY29vcmRpbmF0ZXMgYXJyYXkuXG4gKlxuICogVGhpcyBpcyBhZGFwdGVkIGZyb20gdGhlIGltcGxlbWVudGF0aW9uIGluIFByb2plY3QtT1NSTS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzaW9uXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vUHJvamVjdC1PU1JNL29zcm0tZnJvbnRlbmQvYmxvYi9tYXN0ZXIvV2ViQ29udGVudC9yb3V0aW5nL09TUk0uUm91dGluZ0dlb21ldHJ5LmpzXG4gKi9cbnBvbHlsaW5lLmRlY29kZSA9IGZ1bmN0aW9uKHN0ciwgcHJlY2lzaW9uKSB7XG4gICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgbGF0ID0gMCxcbiAgICAgICAgbG5nID0gMCxcbiAgICAgICAgY29vcmRpbmF0ZXMgPSBbXSxcbiAgICAgICAgc2hpZnQgPSAwLFxuICAgICAgICByZXN1bHQgPSAwLFxuICAgICAgICBieXRlID0gbnVsbCxcbiAgICAgICAgbGF0aXR1ZGVfY2hhbmdlLFxuICAgICAgICBsb25naXR1ZGVfY2hhbmdlLFxuICAgICAgICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uIHx8IDUpO1xuXG4gICAgLy8gQ29vcmRpbmF0ZXMgaGF2ZSB2YXJpYWJsZSBsZW5ndGggd2hlbiBlbmNvZGVkLCBzbyBqdXN0IGtlZXBcbiAgICAvLyB0cmFjayBvZiB3aGV0aGVyIHdlJ3ZlIGhpdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuIEluIGVhY2hcbiAgICAvLyBsb29wIGl0ZXJhdGlvbiwgYSBzaW5nbGUgY29vcmRpbmF0ZSBpcyBkZWNvZGVkLlxuICAgIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcblxuICAgICAgICAvLyBSZXNldCBzaGlmdCwgcmVzdWx0LCBhbmQgYnl0ZVxuICAgICAgICBieXRlID0gbnVsbDtcbiAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGJ5dGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCsrKSAtIDYzO1xuICAgICAgICAgICAgcmVzdWx0IHw9IChieXRlICYgMHgxZikgPDwgc2hpZnQ7XG4gICAgICAgICAgICBzaGlmdCArPSA1O1xuICAgICAgICB9IHdoaWxlIChieXRlID49IDB4MjApO1xuXG4gICAgICAgIGxhdGl0dWRlX2NoYW5nZSA9ICgocmVzdWx0ICYgMSkgPyB+KHJlc3VsdCA+PiAxKSA6IChyZXN1bHQgPj4gMSkpO1xuXG4gICAgICAgIHNoaWZ0ID0gcmVzdWx0ID0gMDtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgICBieXRlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgrKykgLSA2MztcbiAgICAgICAgICAgIHJlc3VsdCB8PSAoYnl0ZSAmIDB4MWYpIDw8IHNoaWZ0O1xuICAgICAgICAgICAgc2hpZnQgKz0gNTtcbiAgICAgICAgfSB3aGlsZSAoYnl0ZSA+PSAweDIwKTtcblxuICAgICAgICBsb25naXR1ZGVfY2hhbmdlID0gKChyZXN1bHQgJiAxKSA/IH4ocmVzdWx0ID4+IDEpIDogKHJlc3VsdCA+PiAxKSk7XG5cbiAgICAgICAgbGF0ICs9IGxhdGl0dWRlX2NoYW5nZTtcbiAgICAgICAgbG5nICs9IGxvbmdpdHVkZV9jaGFuZ2U7XG5cbiAgICAgICAgY29vcmRpbmF0ZXMucHVzaChbbGF0IC8gZmFjdG9yLCBsbmcgLyBmYWN0b3JdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgdGhlIGdpdmVuIFtsYXRpdHVkZSwgbG9uZ2l0dWRlXSBjb29yZGluYXRlcyBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxBcnJheS48TnVtYmVyPj59IGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzaW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5wb2x5bGluZS5lbmNvZGUgPSBmdW5jdGlvbihjb29yZGluYXRlcywgcHJlY2lzaW9uKSB7XG4gICAgaWYgKCFjb29yZGluYXRlcy5sZW5ndGgpIHsgcmV0dXJuICcnOyB9XG5cbiAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbiB8fCA1KSxcbiAgICAgICAgb3V0cHV0ID0gZW5jb2RlKGNvb3JkaW5hdGVzWzBdWzBdLCAwLCBmYWN0b3IpICsgZW5jb2RlKGNvb3JkaW5hdGVzWzBdWzFdLCAwLCBmYWN0b3IpO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYSA9IGNvb3JkaW5hdGVzW2ldLCBiID0gY29vcmRpbmF0ZXNbaSAtIDFdO1xuICAgICAgICBvdXRwdXQgKz0gZW5jb2RlKGFbMF0sIGJbMF0sIGZhY3Rvcik7XG4gICAgICAgIG91dHB1dCArPSBlbmNvZGUoYVsxXSwgYlsxXSwgZmFjdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuZnVuY3Rpb24gZmxpcHBlZChjb29yZHMpIHtcbiAgICB2YXIgZmxpcHBlZCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZsaXBwZWQucHVzaChjb29yZHNbaV0uc2xpY2UoKS5yZXZlcnNlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZmxpcHBlZDtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgR2VvSlNPTiBMaW5lU3RyaW5nIGZlYXR1cmUvZ2VvbWV0cnkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGdlb2pzb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmVjaXNpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbnBvbHlsaW5lLmZyb21HZW9KU09OID0gZnVuY3Rpb24oZ2VvanNvbiwgcHJlY2lzaW9uKSB7XG4gICAgaWYgKGdlb2pzb24gJiYgZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScpIHtcbiAgICAgICAgZ2VvanNvbiA9IGdlb2pzb24uZ2VvbWV0cnk7XG4gICAgfVxuICAgIGlmICghZ2VvanNvbiB8fCBnZW9qc29uLnR5cGUgIT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IG11c3QgYmUgYSBHZW9KU09OIExpbmVTdHJpbmcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvbHlsaW5lLmVuY29kZShmbGlwcGVkKGdlb2pzb24uY29vcmRpbmF0ZXMpLCBwcmVjaXNpb24pO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRvIGEgR2VvSlNPTiBMaW5lU3RyaW5nIGdlb21ldHJ5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmVjaXNpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbnBvbHlsaW5lLnRvR2VvSlNPTiA9IGZ1bmN0aW9uKHN0ciwgcHJlY2lzaW9uKSB7XG4gICAgdmFyIGNvb3JkcyA9IHBvbHlsaW5lLmRlY29kZShzdHIsIHByZWNpc2lvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxuICAgICAgICBjb29yZGluYXRlczogZmxpcHBlZChjb29yZHMpXG4gICAgfTtcbn07XG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcG9seWxpbmU7XG59XG4iLCIvKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAqIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAqIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICogbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy4gVGhlIGZ1bmN0aW9uIGFsc28gaGFzIGEgcHJvcGVydHkgJ2NsZWFyJyBcbiAqIHRoYXQgaXMgYSBmdW5jdGlvbiB3aGljaCB3aWxsIGNsZWFyIHRoZSB0aW1lciB0byBwcmV2ZW50IHByZXZpb3VzbHkgc2NoZWR1bGVkIGV4ZWN1dGlvbnMuIFxuICpcbiAqIEBzb3VyY2UgdW5kZXJzY29yZS5qc1xuICogQHNlZSBodHRwOi8vdW5zY3JpcHRhYmxlLmNvbS8yMDA5LzAzLzIwL2RlYm91bmNpbmctamF2YXNjcmlwdC1tZXRob2RzL1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb24gdG8gd3JhcFxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgaW4gbXMgKGAxMDBgKVxuICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIHRvIGV4ZWN1dGUgYXQgdGhlIGJlZ2lubmluZyAoYGZhbHNlYClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpe1xuICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG4gIGlmIChudWxsID09IHdhaXQpIHdhaXQgPSAxMDA7XG5cbiAgZnVuY3Rpb24gbGF0ZXIoKSB7XG4gICAgdmFyIGxhc3QgPSBEYXRlLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBkZWJvdW5jZWQgPSBmdW5jdGlvbigpe1xuICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICBpZiAoY2FsbE5vdykge1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGRlYm91bmNlZC5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGRlYm91bmNlZDtcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgncXVldWUnLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwucXVldWUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuICBmdW5jdGlvbiBub29wKCkge31cblxuICB2YXIgbm9hYm9ydCA9IHt9O1xuICB2YXIgc3VjY2VzcyA9IFtudWxsXTtcbiAgZnVuY3Rpb24gbmV3UXVldWUoY29uY3VycmVuY3kpIHtcbiAgICBpZiAoIShjb25jdXJyZW5jeSA+PSAxKSkgdGhyb3cgbmV3IEVycm9yO1xuXG4gICAgdmFyIHEsXG4gICAgICAgIHRhc2tzID0gW10sXG4gICAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgICAgd2FpdGluZyA9IDAsXG4gICAgICAgIGFjdGl2ZSA9IDAsXG4gICAgICAgIGVuZGVkID0gMCxcbiAgICAgICAgc3RhcnRpbmcsIC8vIGluc2lkZSBhIHN5bmNocm9ub3VzIHRhc2sgY2FsbGJhY2s/XG4gICAgICAgIGVycm9yLFxuICAgICAgICBjYWxsYmFjayA9IG5vb3AsXG4gICAgICAgIGNhbGxiYWNrQWxsID0gdHJ1ZTtcblxuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgaWYgKHN0YXJ0aW5nKSByZXR1cm47IC8vIGxldCB0aGUgY3VycmVudCB0YXNrIGNvbXBsZXRlXG4gICAgICB3aGlsZSAoc3RhcnRpbmcgPSB3YWl0aW5nICYmIGFjdGl2ZSA8IGNvbmN1cnJlbmN5KSB7XG4gICAgICAgIHZhciBpID0gZW5kZWQgKyBhY3RpdmUsXG4gICAgICAgICAgICB0ID0gdGFza3NbaV0sXG4gICAgICAgICAgICBqID0gdC5sZW5ndGggLSAxLFxuICAgICAgICAgICAgYyA9IHRbal07XG4gICAgICAgIHRbal0gPSBlbmQoaSk7XG4gICAgICAgIC0td2FpdGluZywgKythY3RpdmUsIHRhc2tzW2ldID0gYy5hcHBseShudWxsLCB0KSB8fCBub2Fib3J0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZChpKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZSwgcikge1xuICAgICAgICBpZiAoIXRhc2tzW2ldKSB0aHJvdyBuZXcgRXJyb3I7IC8vIGRldGVjdCBtdWx0aXBsZSBjYWxsYmFja3NcbiAgICAgICAgLS1hY3RpdmUsICsrZW5kZWQsIHRhc2tzW2ldID0gbnVsbDtcbiAgICAgICAgaWYgKGVycm9yICE9IG51bGwpIHJldHVybjsgLy8gb25seSByZXBvcnQgdGhlIGZpcnN0IGVycm9yXG4gICAgICAgIGlmIChlICE9IG51bGwpIHtcbiAgICAgICAgICBhYm9ydChlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRzW2ldID0gcjtcbiAgICAgICAgICBpZiAod2FpdGluZykgc3RhcnQoKTtcbiAgICAgICAgICBlbHNlIGlmICghYWN0aXZlKSBub3RpZnkoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYm9ydChlKSB7XG4gICAgICBlcnJvciA9IGU7IC8vIGlnbm9yZSBuZXcgdGFza3MgYW5kIHNxdWVsY2ggYWN0aXZlIGNhbGxiYWNrc1xuICAgICAgd2FpdGluZyA9IE5hTjsgLy8gc3RvcCBxdWV1ZWQgdGFza3MgZnJvbSBzdGFydGluZ1xuICAgICAgbm90aWZ5KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgICAgaWYgKGVycm9yICE9IG51bGwpIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIGVsc2UgaWYgKGNhbGxiYWNrQWxsKSBjYWxsYmFjayhudWxsLCByZXN1bHRzKTtcbiAgICAgIGVsc2UgY2FsbGJhY2suYXBwbHkobnVsbCwgc3VjY2Vzcy5jb25jYXQocmVzdWx0cykpO1xuICAgIH1cblxuICAgIHJldHVybiBxID0ge1xuICAgICAgZGVmZXI6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBub29wKSB0aHJvdyBuZXcgRXJyb3I7XG4gICAgICAgIHZhciB0ID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICB0LnB1c2goZik7XG4gICAgICAgICsrd2FpdGluZywgdGFza3MucHVzaCh0KTtcbiAgICAgICAgc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9LFxuICAgICAgYWJvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBpID0gZW5kZWQgKyBhY3RpdmUsIHQ7XG4gICAgICAgICAgd2hpbGUgKC0taSA+PSAwKSAodCA9IHRhc2tzW2ldKSAmJiB0LmFib3J0ICYmIHQuYWJvcnQoKTtcbiAgICAgICAgICBhYm9ydChuZXcgRXJyb3IoXCJhYm9ydFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9LFxuICAgICAgYXdhaXQ6IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBub29wKSB0aHJvdyBuZXcgRXJyb3I7XG4gICAgICAgIGNhbGxiYWNrID0gZiwgY2FsbGJhY2tBbGwgPSBmYWxzZTtcbiAgICAgICAgaWYgKCF3YWl0aW5nICYmICFhY3RpdmUpIG5vdGlmeSgpO1xuICAgICAgICByZXR1cm4gcTtcbiAgICAgIH0sXG4gICAgICBhd2FpdEFsbDogZnVuY3Rpb24oZikge1xuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IG5vb3ApIHRocm93IG5ldyBFcnJvcjtcbiAgICAgICAgY2FsbGJhY2sgPSBmLCBjYWxsYmFja0FsbCA9IHRydWU7XG4gICAgICAgIGlmICghd2FpdGluZyAmJiAhYWN0aXZlKSBub3RpZnkoKTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1ZXVlKGNvbmN1cnJlbmN5KSB7XG4gICAgcmV0dXJuIG5ld1F1ZXVlKGFyZ3VtZW50cy5sZW5ndGggPyArY29uY3VycmVuY3kgOiBJbmZpbml0eSk7XG4gIH1cblxuICBxdWV1ZS52ZXJzaW9uID0gXCIxLjIuMVwiO1xuXG4gIHJldHVybiBxdWV1ZTtcblxufSkpOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZ2V0UmVxdWVzdCA9IHJlcXVpcmUoXCIuL2dldF9yZXF1ZXN0XCIpLFxuICAgIHBvbHlsaW5lID0gcmVxdWlyZShcIkBtYXBib3gvcG9seWxpbmVcIiksXG4gICAgcXVldWUgPSByZXF1aXJlKFwicXVldWUtYXN5bmNcIik7XG5cbnZhciBEaXJlY3Rpb25zID0gTC5DbGFzcy5leHRlbmQoe1xuICAgIGluY2x1ZGVzOiBbTC5NaXhpbi5FdmVudHNdLFxuXG4gICAgb3B0aW9uczoge1xuICAgICAgICBhdmFpbGFibGVfcHJvdmlkZXJzOiBbXCJtYXBib3hcIiwgXCJnb29nbGVcIiwgXCJvcGVucm91dGVzZXJ2aWNlXCJdLFxuICAgICAgICBlbmFibGVkX3Byb3ZpZGVyczogW10sXG4gICAgICAgIHVuaXQ6IFwibWV0ZXJzXCIsXG4gICAgICAgIG1hcGJveDoge1xuICAgICAgICAgICAgYXBpX3RlbXBsYXRlOlxuICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9kaXJlY3Rpb25zL3Y1L21hcGJveC9jeWNsaW5nL3t3YXlwb2ludHN9P2dlb21ldHJpZXM9cG9seWxpbmUmYWNjZXNzX3Rva2VuPXt0b2tlbn1cIixcbiAgICAgICAgICAgIGdlb2NvZGVyX3RlbXBsYXRlOlxuICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly9hcGkudGlsZXMubWFwYm94LmNvbS92NC9nZW9jb2RlL21hcGJveC5wbGFjZXMve3F1ZXJ5fS5qc29uP3Byb3hpbWl0eT17cHJveGltaXR5fSZhY2Nlc3NfdG9rZW49e3Rva2VufVwiLFxuICAgICAgICAgICAga2V5OlxuICAgICAgICAgICAgICAgIFwicGsuZXlKMUlqb2liR3hwZFNJc0ltRWlPaUk0ZFc1dVZrVkpJbjAuamhmcExuMkVza182WlNHNjJ5WFlPZ1wiLFxuICAgICAgICAgICAgcHJvZmlsZTogXCJjeWNsaW5nXCIsXG4gICAgICAgICAgICBwYXRoX3N0eWxlOiB7XG4gICAgICAgICAgICAgICAgc3Ryb2tlOiBcIiM0MjY0ZmJcIixcbiAgICAgICAgICAgICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IDAuNzgsXG4gICAgICAgICAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogNVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvcGVucm91dGVzZXJ2aWNlOiB7XG4gICAgICAgICAgICBhcGlfdGVtcGxhdGU6XG4gICAgICAgICAgICAgICAgXCJodHRwczovL2FwaS5vcGVucm91dGVzZXJ2aWNlLm9yZy9jb3JzZGlyZWN0aW9ucz8mY29vcmRpbmF0ZXM9e2Nvb3JkaW5hdGVzfSZpbnN0cnVjdGlvbnM9ZmFsc2UmcHJlZmVyZW5jZT17cHJlZmVyZW5jZX0mcHJvZmlsZT17cHJvZmlsZX0mYXBpX2tleT17dG9rZW59XCIsXG4gICAgICAgICAgICBrZXk6IFwiNThkOTA0YTQ5N2M2N2UwMDAxNWI0NWZjZjI0M2VhY2Y0YjI1NDM0YzZlMjhkN2ZkNjFjOWQzMDlcIixcbiAgICAgICAgICAgIHByZWZlcmVuY2U6IFwiXCIsXG4gICAgICAgICAgICBwcm9maWxlOiBcImN5Y2xpbmctcmVndWxhclwiLFxuICAgICAgICAgICAgcGF0aF9zdHlsZToge1xuICAgICAgICAgICAgICAgIHN0cm9rZTogXCIjY2Y1ZjVmXCIsXG4gICAgICAgICAgICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiAwLjc4LFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ29vZ2xlOiB7XG4gICAgICAgICAgICBhcGlfdGVtcGxhdGU6XG4gICAgICAgICAgICAgICAgXCJodHRwczovL2x1bGl1Lm1lL2dtYXBzd3JhcHBlcj9vcmlnaW49e29yaWdpbn0mZGVzdGluYXRpb249e2Rlc3RpbmF0aW9ufSZtb2RlPWJpY3ljbGluZyZrZXk9e3Rva2VufVwiLFxuICAgICAgICAgICAga2V5OiBcIkFJemFTeURjMmdhZFdJNG51blliMGk1TXhfUDNBSF95RFRpTXpBWVwiLFxuICAgICAgICAgICAgcHJvZmlsZTogXCJiaWN5Y2xpbmdcIixcbiAgICAgICAgICAgIHBhdGhfc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBzdHJva2U6IFwiIzBmOWQ1OFwiLFxuICAgICAgICAgICAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogMC43OCxcbiAgICAgICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiA1XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlyZWN0aW9uczoge1xuICAgICAgICByb3V0ZXM6IHtcbiAgICAgICAgICAgIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICAgICAgICAgIGZlYXR1cmVzOiBbXVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl93YXlwb2ludHMgPSBbXTtcbiAgICB9LFxuXG4gICAgZ2V0T3JpZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luO1xuICAgIH0sXG5cbiAgICBnZXREZXN0aW5hdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlc3RpbmF0aW9uO1xuICAgIH0sXG5cbiAgICBzZXRPcmlnaW46IGZ1bmN0aW9uKG9yaWdpbikge1xuICAgICAgICBvcmlnaW4gPSB0aGlzLl9ub3JtYWxpemVXYXlwb2ludChvcmlnaW4pO1xuXG4gICAgICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB0aGlzLmZpcmUoXCJvcmlnaW5cIiwge1xuICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFvcmlnaW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3VubG9hZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldERlc3RpbmF0aW9uOiBmdW5jdGlvbihkZXN0aW5hdGlvbikge1xuICAgICAgICBkZXN0aW5hdGlvbiA9IHRoaXMuX25vcm1hbGl6ZVdheXBvaW50KGRlc3RpbmF0aW9uKTtcblxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgIHRoaXMuZmlyZShcImRlc3RpbmF0aW9uXCIsIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvblxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl91bmxvYWQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRXYXlwb2ludHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2F5cG9pbnRzO1xuICAgIH0sXG5cbiAgICBzZXRXYXlwb2ludHM6IGZ1bmN0aW9uKHdheXBvaW50cykge1xuICAgICAgICB0aGlzLl93YXlwb2ludHMgPSB3YXlwb2ludHMubWFwKHRoaXMuX25vcm1hbGl6ZVdheXBvaW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFkZFdheXBvaW50OiBmdW5jdGlvbihpbmRleCwgd2F5cG9pbnQpIHtcbiAgICAgICAgdGhpcy5fd2F5cG9pbnRzLnNwbGljZShpbmRleCwgMCwgdGhpcy5fbm9ybWFsaXplV2F5cG9pbnQod2F5cG9pbnQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZVdheXBvaW50OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB0aGlzLl93YXlwb2ludHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFdheXBvaW50OiBmdW5jdGlvbihpbmRleCwgd2F5cG9pbnQpIHtcbiAgICAgICAgdGhpcy5fd2F5cG9pbnRzW2luZGV4XSA9IHRoaXMuX25vcm1hbGl6ZVdheXBvaW50KHdheXBvaW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbyA9IHRoaXMub3JpZ2luLFxuICAgICAgICAgICAgZCA9IHRoaXMuZGVzdGluYXRpb247XG5cbiAgICAgICAgdGhpcy5vcmlnaW4gPSBkO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbztcbiAgICAgICAgdGhpcy5fd2F5cG9pbnRzLnJldmVyc2UoKTtcblxuICAgICAgICB0aGlzLmZpcmUoXCJvcmlnaW5cIiwge1xuICAgICAgICAgICAgb3JpZ2luOiB0aGlzLm9yaWdpblxuICAgICAgICB9KS5maXJlKFwiZGVzdGluYXRpb25cIiwge1xuICAgICAgICAgICAgZGVzdGluYXRpb246IHRoaXMuZGVzdGluYXRpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNlbGVjdFJvdXRlOiBmdW5jdGlvbihyb3V0ZSkge1xuICAgICAgICB0aGlzLmZpcmUoXCJzZWxlY3RSb3V0ZVwiLCB7XG4gICAgICAgICAgICByb3V0ZTogcm91dGVcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNlbGVjdFRyYWNrOiBmdW5jdGlvbih0cmFjaykge1xuICAgICAgICB0aGlzLl9jbGVhclJlc3VsdFJvdXRlcygpO1xuICAgICAgICB0aGlzLmZpcmUoXCJzZWxlY3RUcmFja1wiLCB7XG4gICAgICAgICAgICB0cmFjazogdHJhY2suR2VvSlNPTlxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgaGlnaGxpZ2h0Um91dGU6IGZ1bmN0aW9uKHJvdXRlKSB7XG4gICAgICAgIHRoaXMuZmlyZShcImhpZ2hsaWdodFJvdXRlXCIsIHtcbiAgICAgICAgICAgIHJvdXRlOiByb3V0ZVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgaGlnaGxpZ2h0U3RlcDogZnVuY3Rpb24oc3RlcCkge1xuICAgICAgICB0aGlzLmZpcmUoXCJoaWdobGlnaHRTdGVwXCIsIHtcbiAgICAgICAgICAgIHN0ZXA6IHN0ZXBcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGVuYWJsZVByb3ZpZGVyOiBmdW5jdGlvbihwcm92aWRlciwgaXNfZW5hYmxlZCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXZhaWxhYmxlX3Byb3ZpZGVycy5pbmRleE9mKHByb3ZpZGVyKSA+IC0xICYmXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZF9wcm92aWRlcnMuaW5kZXhPZihwcm92aWRlcikgPT09IC0xICYmXG4gICAgICAgICAgICBpc19lbmFibGVkXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWRfcHJvdmlkZXJzLnB1c2gocHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hdmFpbGFibGVfcHJvdmlkZXJzLmluZGV4T2YocHJvdmlkZXIpID4gLTEgJiZcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkX3Byb3ZpZGVycy5pbmRleE9mKHByb3ZpZGVyKSA+IC0xICYmXG4gICAgICAgICAgICAhaXNfZW5hYmxlZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5vcHRpb25zLmVuYWJsZWRfcHJvdmlkZXJzLmluZGV4T2YocHJvdmlkZXIpO1xuICAgICAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkX3Byb3ZpZGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXJlY3Rpb25zLnJvdXRlcy5mZWF0dXJlcyA9IFtdO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZF9wcm92aWRlcnMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbnMucm91dGVzLmZlYXR1cmVzLnB1c2goXG4gICAgICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb25zW3BdLnJvdXRlc1swXS5nZW9tZXRyeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmlyZShcImxvYWRcIiwgdGhpcy5kaXJlY3Rpb25zKTtcbiAgICB9LFxuXG4gICAgcXVlcnlVUkw6IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gb3B0cy5wcm92aWRlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLm9wdGlvbnNbcHJvdmlkZXJdLmFwaV90ZW1wbGF0ZTtcbiAgICAgICAgdmFyIHBvaW50cyA9IFwiXCI7XG4gICAgICAgIGlmIChwcm92aWRlciA9PT0gXCJtYXBib3hcIikge1xuICAgICAgICAgICAgcG9pbnRzID0gW3RoaXMuZ2V0T3JpZ2luKCksIHRoaXMuZ2V0RGVzdGluYXRpb24oKV1cbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbihcIjtcIik7XG4gICAgICAgICAgICByZXR1cm4gTC5VdGlsLnRlbXBsYXRlKHRlbXBsYXRlLCB7XG4gICAgICAgICAgICAgICAgdG9rZW46IHRoaXMub3B0aW9ucy5tYXBib3gua2V5LFxuICAgICAgICAgICAgICAgIHdheXBvaW50czogcG9pbnRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXIgPT09IFwib3BlbnJvdXRlc2VydmljZVwiKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBbdGhpcy5nZXRPcmlnaW4oKSwgdGhpcy5nZXREZXN0aW5hdGlvbigpXVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcC5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKFwiJTdDXCIpO1xuICAgICAgICAgICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkoXCJwcmVmZXJlbmNlXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9wZW5yb3V0ZXNlcnZpY2UucHJlZmVyZW5jZSA9IG9wdHMucHJlZmVyZW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KFwicHJvZmlsZVwiKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vcGVucm91dGVzZXJ2aWNlLnByb2ZpbGUgPSBvcHRzLnByb2ZpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTC5VdGlsLnRlbXBsYXRlKHRlbXBsYXRlLCB7XG4gICAgICAgICAgICAgICAgdG9rZW46IHRoaXMub3B0aW9ucy5vcGVucm91dGVzZXJ2aWNlLmtleSxcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogcG9pbnRzLFxuICAgICAgICAgICAgICAgIHByZWZlcmVuY2U6IHRoaXMub3B0aW9ucy5vcGVucm91dGVzZXJ2aWNlLnByZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgcHJvZmlsZTogdGhpcy5vcHRpb25zLm9wZW5yb3V0ZXNlcnZpY2UucHJvZmlsZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVyID09PSBcImdvb2dsZVwiKSB7XG4gICAgICAgICAgICB2YXIgb3JpZ2luX2Nvb3JkcyA9IHRoaXMuZ2V0T3JpZ2luKCkuZ2VvbWV0cnkuY29vcmRpbmF0ZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIHZhciBkZXN0X2Nvb3JkcyA9IHRoaXMuZ2V0RGVzdGluYXRpb24oKS5nZW9tZXRyeS5jb29yZGluYXRlcy5zbGljZSgpO1xuICAgICAgICAgICAgcmV0dXJuIEwuVXRpbC50ZW1wbGF0ZSh0ZW1wbGF0ZSwge1xuICAgICAgICAgICAgICAgIHRva2VuOiB0aGlzLm9wdGlvbnMuZ29vZ2xlLmtleSxcbiAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbl9jb29yZHMucmV2ZXJzZSgpLmpvaW4oXCIsXCIpLFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBkZXN0X2Nvb3Jkcy5yZXZlcnNlKCkuam9pbihcIixcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIF9jbGVhclJlc3VsdFJvdXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5hdmFpbGFibGVfcHJvdmlkZXJzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9ucy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uc1twXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkX3Byb3ZpZGVycyA9IFtdO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbnMucm91dGVzID0ge1xuICAgICAgICAgICAgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgICAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmlyZShcImNoZWNrbWFwYm94XCIsIHsgY2hlY2tlZDogZmFsc2UgfSk7XG4gICAgICAgIHRoaXMuZmlyZShcImNoZWNrZ29vZ2xlXCIsIHsgY2hlY2tlZDogZmFsc2UgfSk7XG4gICAgICAgIHRoaXMuZmlyZShcImNoZWNrb3JzXCIsIHsgY2hlY2tlZDogZmFsc2UgfSk7XG4gICAgfSxcblxuICAgIF9jb25zdHJ1Y3RSb3V0aW5nUmVzdWx0OiBmdW5jdGlvbihyZXNwLCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLmRpcmVjdGlvbnNbcHJvdmlkZXJdID0gcmVzcDtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb25zW3Byb3ZpZGVyXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHByb3ZpZGVyID09PSBcIm1hcGJveFwiKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbnNbcHJvdmlkZXJdLm9yaWdpbiA9IHJlc3Aud2F5cG9pbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb25zW3Byb3ZpZGVyXS5kZXN0aW5hdGlvbiA9IHJlc3Aud2F5cG9pbnRzLnNsaWNlKC0xKVswXTtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uc1twcm92aWRlcl0ud2F5cG9pbnRzLmZvckVhY2goZnVuY3Rpb24od3ApIHtcbiAgICAgICAgICAgICAgICB3cC5nZW9tZXRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJQb2ludFwiLFxuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogd3AubG9jYXRpb25cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHdwLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHdwLm5hbWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbnNbcHJvdmlkZXJdLndheXBvaW50cyA9IHJlc3Aud2F5cG9pbnRzLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXIgPT09IFwib3BlbnJvdXRlc2VydmljZVwiKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbnNbcHJvdmlkZXJdLm9yaWdpbiA9IHJlc3AuaW5mby5xdWVyeS5jb29yZGluYXRlc1swXTtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uc1twcm92aWRlcl0uZGVzdGluYXRpb24gPVxuICAgICAgICAgICAgICAgIHJlc3AuaW5mby5xdWVyeS5jb29yZGluYXRlc1sxXTtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uc1twcm92aWRlcl0ud2F5cG9pbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVyID09PSBcIm1hcGJveFwiIHx8IHByb3ZpZGVyID09PSBcIm9wZW5yb3V0ZXNlcnZpY2VcIikge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3Rpb25zW3Byb3ZpZGVyXS5yb3V0ZXMuZm9yRWFjaChmdW5jdGlvbihyb3V0ZSkge1xuICAgICAgICAgICAgICAgIHJvdXRlLmdlb21ldHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogdGhpcy5vcHRpb25zW3Byb3ZpZGVyXS5wYXRoX3N0eWxlLFxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJMaW5lU3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogcG9seWxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZGVjb2RlKHJvdXRlLmdlb21ldHJ5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXIgPT09IFwiZ29vZ2xlXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uc1twcm92aWRlcl0ub3JpZ2luID0gdGhpcy5vcmlnaW47XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbnNbcHJvdmlkZXJdLmRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uc1twcm92aWRlcl0ud2F5cG9pbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGlvbnNbcHJvdmlkZXJdLnJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uKHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcm91dGUuZ2VvbWV0cnkgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB0aGlzLm9wdGlvbnNbcHJvdmlkZXJdLnBhdGhfc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkxpbmVTdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBwb2x5bGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5kZWNvZGUocm91dGUub3ZlcnZpZXdfcG9seWxpbmUucG9pbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBxdWVyeWFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPcmlnaW4oKSAmJiB0aGlzLmdldERlc3RpbmF0aW9uKCk7XG4gICAgfSxcblxuICAgIHF1ZXJ5OiBmdW5jdGlvbihvcHRzKSB7XG4gICAgICAgIGlmICghb3B0cykgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5xdWVyeWFibGUoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHRoaXMuX3F1ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLl9xdWVyeS5hYm9ydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RzICYmIHRoaXMuX3JlcXVlc3RzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24oZ2V0UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGdldFJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuXG4gICAgICAgIHZhciBxID0gcXVldWUoKTtcblxuICAgICAgICB2YXIgcHRzID0gW3RoaXMub3JpZ2luLCB0aGlzLmRlc3RpbmF0aW9uXS5jb25jYXQodGhpcy5fd2F5cG9pbnRzKTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBwdHMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAhcHRzW2ldLmdlb21ldHJ5LmNvb3JkaW5hdGVzIHx8XG4gICAgICAgICAgICAgICAgIXB0c1tpXS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KFwibmFtZVwiKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcS5kZWZlcihMLmJpbmQodGhpcy5fZ2VvY29kZSwgdGhpcyksIHB0c1tpXSwgb3B0cy5wcm94aW1pdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcS5hd2FpdChcbiAgICAgICAgICAgIEwuYmluZChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpcmUoXCJlcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVlcnkgPSBnZXRSZXF1ZXN0KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5VVJMKG9wdHMpLFxuICAgICAgICAgICAgICAgICAgICBMLmJpbmQoZnVuY3Rpb24oZXJyLCByZXNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWVyeSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maXJlKFwiZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29uc3RydWN0Um91dGluZ1Jlc3VsdChyZXNwLCBvcHRzLnByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcmlnaW4ucHJvcGVydGllcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLmRpcmVjdGlvbnMub3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbnMub3JpZ2luID0gdGhpcy5vcmlnaW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5kZXN0aW5hdGlvbi5wcm9wZXJ0aWVzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gdGhpcy5kaXJlY3Rpb25zLmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbnMuZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmFibGVQcm92aWRlcihvcHRzLnByb3ZpZGVyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSwgdGhpcylcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2dlb2NvZGU6IGZ1bmN0aW9uKHdheXBvaW50LCBwcm94aW1pdHksIGNiKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdHMpIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgICAgIHRoaXMuX3JlcXVlc3RzLnB1c2goXG4gICAgICAgICAgICBnZXRSZXF1ZXN0KFxuICAgICAgICAgICAgICAgIEwuVXRpbC50ZW1wbGF0ZSh0aGlzLm9wdGlvbnMubWFwYm94Lmdlb2NvZGVyX3RlbXBsYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB3YXlwb2ludC5wcm9wZXJ0aWVzLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICB0b2tlbjogdGhpcy5vcHRpb25zLm1hcGJveC5rZXkgfHwgTC5tYXBib3guYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHByb3hpbWl0eTogcHJveGltaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtwcm94aW1pdHkubG5nLCBwcm94aW1pdHkubGF0XS5qb2luKFwiLFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgTC5iaW5kKGZ1bmN0aW9uKGVyciwgcmVzcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzcC5mZWF0dXJlcyB8fCAhcmVzcC5mZWF0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiTm8gcmVzdWx0cyBmb3VuZCBmb3IgcXVlcnkgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2F5cG9pbnQucHJvcGVydGllcy5xdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3YXlwb2ludC5nZW9tZXRyeS5jb29yZGluYXRlcyA9IHJlc3AuZmVhdHVyZXNbMF0uY2VudGVyO1xuICAgICAgICAgICAgICAgICAgICB3YXlwb2ludC5wcm9wZXJ0aWVzLm5hbWUgPSByZXNwLmZlYXR1cmVzWzBdLnBsYWNlX25hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcylcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgX3VubG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3dheXBvaW50cyA9IFtdO1xuICAgICAgICBkZWxldGUgdGhpcy5kaXJlY3Rpb25zO1xuICAgICAgICB0aGlzLmZpcmUoXCJ1bmxvYWRcIik7XG4gICAgfSxcblxuICAgIF9ub3JtYWxpemVXYXlwb2ludDogZnVuY3Rpb24od2F5cG9pbnQpIHtcbiAgICAgICAgaWYgKCF3YXlwb2ludCB8fCB3YXlwb2ludC50eXBlID09PSBcIkZlYXR1cmVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHdheXBvaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzLFxuICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuXG4gICAgICAgIGlmICh3YXlwb2ludCBpbnN0YW5jZW9mIEwuTGF0TG5nKSB7XG4gICAgICAgICAgICB3YXlwb2ludCA9IHdheXBvaW50LndyYXAoKTtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzID0gcHJvcGVydGllcy5xdWVyeSA9IFt3YXlwb2ludC5sbmcsIHdheXBvaW50LmxhdF07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdheXBvaW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnF1ZXJ5ID0gd2F5cG9pbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiUG9pbnRcIixcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzXG4gICAgICAgIH07XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRGlyZWN0aW9ucyhvcHRpb25zKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkMyA9IHJlcXVpcmUoJy4uL2xpYi9kMycpLFxuICAgIGZvcm1hdCA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgZGlyZWN0aW9ucykge1xuICAgIHZhciBjb250cm9sID0ge30sIG1hcDtcblxuICAgIGNvbnRyb2wuYWRkVG8gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICBtYXAgPSBfO1xuICAgICAgICByZXR1cm4gY29udHJvbDtcbiAgICB9O1xuXG4gICAgY29udGFpbmVyID0gZDMuc2VsZWN0KEwuRG9tVXRpbC5nZXQoY29udGFpbmVyKSlcbiAgICAgICAgLmNsYXNzZWQoJ21hcGJveC1kaXJlY3Rpb25zLWVycm9ycycsIHRydWUpO1xuXG4gICAgZGlyZWN0aW9ucy5vbignbG9hZCB1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRhaW5lclxuICAgICAgICAgICAgLmNsYXNzZWQoJ21hcGJveC1lcnJvci1hY3RpdmUnLCBmYWxzZSlcbiAgICAgICAgICAgIC5odG1sKCcnKTtcbiAgICB9KTtcblxuICAgIGRpcmVjdGlvbnMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY29udGFpbmVyXG4gICAgICAgICAgICAuY2xhc3NlZCgnbWFwYm94LWVycm9yLWFjdGl2ZScsIHRydWUpXG4gICAgICAgICAgICAuaHRtbCgnJylcbiAgICAgICAgICAgIC5hcHBlbmQoJ3NwYW4nKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ21hcGJveC1kaXJlY3Rpb25zLWVycm9yJylcbiAgICAgICAgICAgIC50ZXh0KGUuZXJyb3IpO1xuXG4gICAgICAgIGNvbnRhaW5lclxuICAgICAgICAgICAgLmluc2VydCgnc3BhbicsICdzcGFuJylcbiAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdtYXBib3gtZGlyZWN0aW9ucy1pY29uIG1hcGJveC1lcnJvci1pY29uJyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29udHJvbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGR1cmF0aW9uOiBmdW5jdGlvbiAocykge1xuICAgICAgICB2YXIgbSA9IE1hdGguZmxvb3IocyAvIDYwKSxcbiAgICAgICAgICAgIGggPSBNYXRoLmZsb29yKG0gLyA2MCk7XG4gICAgICAgIHMgJT0gNjA7XG4gICAgICAgIG0gJT0gNjA7XG4gICAgICAgIGlmIChoID09PSAwICYmIG0gPT09IDApIHJldHVybiBzICsgJyBzJztcbiAgICAgICAgaWYgKGggPT09IDApIHJldHVybiBtICsgJyBtaW4nO1xuICAgICAgICByZXR1cm4gaCArICcgaCAnICsgbSArICcgbWluJztcbiAgICB9LFxuXG4gICAgaW1wZXJpYWw6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHZhciBtaSA9IG0gLyAxNjA5LjM0NDtcbiAgICAgICAgaWYgKG1pID49IDEwMCkgcmV0dXJuIG1pLnRvRml4ZWQoMCkgKyAnIG1pJztcbiAgICAgICAgaWYgKG1pID49IDEwKSAgcmV0dXJuIG1pLnRvRml4ZWQoMSkgKyAnIG1pJztcbiAgICAgICAgaWYgKG1pID49IDAuMSkgcmV0dXJuIG1pLnRvRml4ZWQoMikgKyAnIG1pJztcbiAgICAgICAgcmV0dXJuIChtaSAqIDUyODApLnRvRml4ZWQoMCkgKyAnIGZ0JztcbiAgICB9LFxuXG4gICAgbWV0cmljOiBmdW5jdGlvbiAobSkge1xuICAgICAgICBpZiAobSA+PSAxMDAwMDApIHJldHVybiAobSAvIDEwMDApLnRvRml4ZWQoMCkgKyAnIGttJztcbiAgICAgICAgaWYgKG0gPj0gMTAwMDApICByZXR1cm4gKG0gLyAxMDAwKS50b0ZpeGVkKDEpICsgJyBrbSc7XG4gICAgICAgIGlmIChtID49IDEwMCkgICAgcmV0dXJuIChtIC8gMTAwMCkudG9GaXhlZCgyKSArICcga20nO1xuICAgICAgICByZXR1cm4gbS50b0ZpeGVkKDApICsgJyBtJztcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29yc2xpdGUgPSByZXF1aXJlKCdAbWFwYm94L2NvcnNsaXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBjb3JzbGl0ZSh1cmwsIGZ1bmN0aW9uIChlcnIsIHJlc3ApIHtcbiAgICAgICAgaWYgKGVyciAmJiBlcnIudHlwZSA9PT0gJ2Fib3J0Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVyciAmJiAhZXJyLnJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXNwID0gcmVzcCB8fCBlcnI7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3AgPSBKU09OLnBhcnNlKHJlc3AucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihyZXNwLnJlc3BvbnNlVGV4dCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3AuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IocmVzcC5lcnJvcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3ApO1xuICAgIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZDMgPSByZXF1aXJlKFwiLi4vbGliL2QzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGlyZWN0aW9ucykge1xuICAgIHZhciBjb250cm9sID0ge30sXG4gICAgICAgIG1hcDtcbiAgICB2YXIgb3JpZ0NoYW5nZSA9IGZhbHNlLFxuICAgICAgICBkZXN0Q2hhbmdlID0gZmFsc2U7XG5cbiAgICBjb250cm9sLmFkZFRvID0gZnVuY3Rpb24oXykge1xuICAgICAgICBtYXAgPSBfO1xuICAgICAgICByZXR1cm4gY29udHJvbDtcbiAgICB9O1xuXG4gICAgY29udGFpbmVyID0gZDNcbiAgICAgICAgLnNlbGVjdChMLkRvbVV0aWwuZ2V0KGNvbnRhaW5lcikpXG4gICAgICAgIC5jbGFzc2VkKFwibWFwYm94LWRpcmVjdGlvbnMtaW5wdXRzXCIsIHRydWUpO1xuXG4gICAgdmFyIGZvcm0gPSBjb250YWluZXIuYXBwZW5kKFwiZm9ybVwiKS5vbihcImtleXByZXNzXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZDMuZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAob3JpZ0NoYW5nZSkgZGlyZWN0aW9ucy5zZXRPcmlnaW4ob3JpZ2luSW5wdXQucHJvcGVydHkoXCJ2YWx1ZVwiKSk7XG4gICAgICAgICAgICBpZiAoZGVzdENoYW5nZSlcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25zLnNldERlc3RpbmF0aW9uKGRlc3RpbmF0aW9uSW5wdXQucHJvcGVydHkoXCJ2YWx1ZVwiKSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9ucy5xdWVyeWFibGUoKSlcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGlyZWN0aW9uUHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvblByb3ZpZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25Qcm92aWRlcnNba2V5XSA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMucXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3hpbWl0eTogbWFwLmdldENlbnRlcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3JpZ0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgZGVzdENoYW5nZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgb3JpZ2luID0gZm9ybS5hcHBlbmQoXCJkaXZcIikuYXR0cihcImNsYXNzXCIsIFwibWFwYm94LWRpcmVjdGlvbnMtb3JpZ2luXCIpO1xuXG4gICAgb3JpZ2luXG4gICAgICAgIC5hcHBlbmQoXCJsYWJlbFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibWFwYm94LWZvcm0tbGFiZWxcIilcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9ucy5nZXRPcmlnaW4oKSBpbnN0YW5jZW9mIEwuTGF0TG5nKSB7XG4gICAgICAgICAgICAgICAgbWFwLnBhblRvKGRpcmVjdGlvbnMuZ2V0T3JpZ2luKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibWFwYm94LWRpcmVjdGlvbnMtaWNvbiBtYXBib3gtZGVwYXJ0LWljb25cIik7XG5cbiAgICB2YXIgb3JpZ2luSW5wdXQgPSBvcmlnaW5cbiAgICAgICAgLmFwcGVuZChcImlucHV0XCIpXG4gICAgICAgIC5hdHRyKFwidHlwZVwiLCBcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJyZXF1aXJlZFwiLCBcInJlcXVpcmVkXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJhaXItb3JpZ2luLWlucHV0XCIpXG4gICAgICAgIC5hdHRyKFwicGxhY2Vob2xkZXJcIiwgXCJTdGFydFwiKVxuICAgICAgICAub24oXCJpbnB1dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghb3JpZ0NoYW5nZSkgb3JpZ0NoYW5nZSA9IHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgb3JpZ2luXG4gICAgICAgIC5hcHBlbmQoXCJkaXZcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm1hcGJveC1kaXJlY3Rpb25zLWljb24gbWFwYm94LWNsb3NlLWljb25cIilcbiAgICAgICAgLmF0dHIoXCJ0aXRsZVwiLCBcIkNsZWFyIHZhbHVlXCIpXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGlyZWN0aW9ucy5zZXRPcmlnaW4odW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG5cbiAgICBmb3JtXG4gICAgICAgIC5hcHBlbmQoXCJzcGFuXCIpXG4gICAgICAgIC5hdHRyKFxuICAgICAgICAgICAgXCJjbGFzc1wiLFxuICAgICAgICAgICAgXCJtYXBib3gtZGlyZWN0aW9ucy1pY29uIG1hcGJveC1yZXZlcnNlLWljb24gbWFwYm94LWRpcmVjdGlvbnMtcmV2ZXJzZS1pbnB1dFwiXG4gICAgICAgIClcbiAgICAgICAgLmF0dHIoXCJ0aXRsZVwiLCBcIlJldmVyc2Ugb3JpZ2luICYgZGVzdGluYXRpb25cIilcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGlyZWN0aW9uUHJvdmlkZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25Qcm92aWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25Qcm92aWRlcnNba2V5XSA9PT0gdHJ1ZVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25zLnJldmVyc2UoKS5xdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjoga2V5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICB2YXIgZGVzdGluYXRpb24gPSBmb3JtXG4gICAgICAgIC5hcHBlbmQoXCJkaXZcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm1hcGJveC1kaXJlY3Rpb25zLWRlc3RpbmF0aW9uXCIpO1xuXG4gICAgZGVzdGluYXRpb25cbiAgICAgICAgLmFwcGVuZChcImxhYmVsXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJtYXBib3gtZm9ybS1sYWJlbFwiKVxuICAgICAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zLmdldERlc3RpbmF0aW9uKCkgaW5zdGFuY2VvZiBMLkxhdExuZykge1xuICAgICAgICAgICAgICAgIG1hcC5wYW5UbyhkaXJlY3Rpb25zLmdldERlc3RpbmF0aW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuYXBwZW5kKFwic3BhblwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibWFwYm94LWRpcmVjdGlvbnMtaWNvbiBtYXBib3gtYXJyaXZlLWljb25cIik7XG5cbiAgICB2YXIgZGVzdGluYXRpb25JbnB1dCA9IGRlc3RpbmF0aW9uXG4gICAgICAgIC5hcHBlbmQoXCJpbnB1dFwiKVxuICAgICAgICAuYXR0cihcInR5cGVcIiwgXCJ0ZXh0XCIpXG4gICAgICAgIC5hdHRyKFwicmVxdWlyZWRcIiwgXCJyZXF1aXJlZFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwiYWlyLWRlc3RpbmF0aW9uLWlucHV0XCIpXG4gICAgICAgIC5hdHRyKFwicGxhY2Vob2xkZXJcIiwgXCJFbmRcIilcbiAgICAgICAgLm9uKFwiaW5wdXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIWRlc3RDaGFuZ2UpIGRlc3RDaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9KTtcblxuICAgIGRlc3RpbmF0aW9uXG4gICAgICAgIC5hcHBlbmQoXCJkaXZcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm1hcGJveC1kaXJlY3Rpb25zLWljb24gbWFwYm94LWNsb3NlLWljb25cIilcbiAgICAgICAgLmF0dHIoXCJ0aXRsZVwiLCBcIkNsZWFyIHZhbHVlXCIpXG4gICAgICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGlyZWN0aW9ucy5zZXREZXN0aW5hdGlvbih1bmRlZmluZWQpO1xuICAgICAgICB9KTtcblxuICAgIHZhciBkaXJlY3Rpb25Qcm92aWRlcnMgPSB7XG4gICAgICAgIG1hcGJveDogZmFsc2UsXG4gICAgICAgIG9wZW5yb3V0ZXNlcnZpY2U6IGZhbHNlLFxuICAgICAgICBnb29nbGU6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vT3B0aW9ucyBibG9jayBmb3IgTWFwYm94IGN5Y2xpbmcgcGF0aCBmaW5kaW5nXG4gICAgdmFyIG1hcGJveERpcmVjdGlvbnMgPSBmb3JtXG4gICAgICAgIC5hcHBlbmQoXCJkaXZcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcIm1hcGJveC1kaXJlY3Rpb25zXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJtYXBib3gtZGlyZWN0aW9ucy1wcm9maWxlXCIpO1xuXG4gICAgdmFyIGNoZWNrYm94TWFwYm94ID0gbWFwYm94RGlyZWN0aW9uc1xuICAgICAgICAuYXBwZW5kKFwiaW5wdXRcIilcbiAgICAgICAgLmF0dHIoXCJ0eXBlXCIsIFwiY2hlY2tib3hcIilcbiAgICAgICAgLmF0dHIoXCJuYW1lXCIsIFwiZW5hYmxlZFwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwic2hvdy1tYXBib3gtY3ljbGluZ1wiKVxuICAgICAgICAucHJvcGVydHkoXCJjaGVja2VkXCIsIGZhbHNlKVxuICAgICAgICAub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvblByb3ZpZGVycy5tYXBib3ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMucXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogXCJtYXBib3hcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25Qcm92aWRlcnMubWFwYm94ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9ucy5lbmFibGVQcm92aWRlcihcIm1hcGJveFwiLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgLy9tYXBib3hEaXJlY3Rpb25zLmFwcGVuZCgnaDMnKVxuICAgIC8vLmF0dHIoJ3ZhbHVlJywgJ01BUEJPWCcpXG4gICAgLy8uYXR0cignc3R5bGUnLCAnbWFyZ2luOiA1cHggMHB4IDBweCA1cHgnKVxuICAgIC8vLnRleHQoJ01BUEJPWCBESVJFQ1RJT05TJyk7XG5cbiAgICBtYXBib3hEaXJlY3Rpb25zXG4gICAgICAgIC5hcHBlbmQoXCJsYWJlbFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiYWlyLWhlYWRpbmctbGFiZWxcIilcbiAgICAgICAgLmF0dHIoXCJmb3JcIiwgXCJzaG93LW1hcGJveC1jeWNsaW5nXCIpXG4gICAgICAgIC50ZXh0KFwiTUFQQk9YIERJUkVDVElPTlNcIik7XG5cbiAgICB2YXIgZ29vZ2xlRGlyZWN0aW9ucyA9IGZvcm1cbiAgICAgICAgLmFwcGVuZChcImRpdlwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwiZ29vZ2xlLWRpcmVjdGlvbnMtcHJvZmlsZVwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibWFwYm94LWRpcmVjdGlvbnMtcHJvZmlsZVwiKTtcblxuICAgIHZhciBjaGVja2JveEdvb2dsZSA9IGdvb2dsZURpcmVjdGlvbnNcbiAgICAgICAgLmFwcGVuZChcImlucHV0XCIpXG4gICAgICAgIC5hdHRyKFwidHlwZVwiLCBcImNoZWNrYm94XCIpXG4gICAgICAgIC5hdHRyKFwibmFtZVwiLCBcImVuYWJsZWRcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcInNob3ctZ29vZ2xlLWN5Y2xpbmdcIilcbiAgICAgICAgLnByb3BlcnR5KFwiY2hlY2tlZFwiLCBmYWxzZSlcbiAgICAgICAgLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25Qcm92aWRlcnMuZ29vZ2xlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25zLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IFwiZ29vZ2xlXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uUHJvdmlkZXJzLmdvb2dsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMuZW5hYmxlUHJvdmlkZXIoXCJnb29nbGVcIiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIGdvb2dsZURpcmVjdGlvbnNcbiAgICAgICAgLmFwcGVuZChcImxhYmVsXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJhaXItaGVhZGluZy1sYWJlbFwiKVxuICAgICAgICAuYXR0cihcImZvclwiLCBcInNob3ctZ29vZ2xlLWN5Y2xpbmdcIilcbiAgICAgICAgLnRleHQoXCJHT09HTEUgTUFQU1wiKTtcblxuICAgIC8vT3B0aW9ucyBibG9jayBmb3IgT3BlblJvdXRlU2VydmljZSBjeWNsaW5nIHBhdGggZmluZGluZ1xuICAgIHZhciBvcnNEaXJlY3Rpb25zID0gZm9ybVxuICAgICAgICAuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJvcnMtZGlyZWN0aW9uc1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibWFwYm94LWRpcmVjdGlvbnMtcHJvZmlsZVwiKTtcblxuICAgIHZhciBjaGVja2JveE9SUyA9IG9yc0RpcmVjdGlvbnNcbiAgICAgICAgLmFwcGVuZChcImlucHV0XCIpXG4gICAgICAgIC5hdHRyKFwidHlwZVwiLCBcImNoZWNrYm94XCIpXG4gICAgICAgIC5hdHRyKFwibmFtZVwiLCBcImVuYWJsZWRcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcInNob3ctb3JzLWN5Y2xpbmdcIilcbiAgICAgICAgLnByb3BlcnR5KFwiY2hlY2tlZFwiLCBmYWxzZSlcbiAgICAgICAgLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25Qcm92aWRlcnMub3BlbnJvdXRlc2VydmljZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2hhbmdlT1JTQ3ljbGluZ09wdGlvbigpO1xuICAgICAgICAgICAgICAgIGRpc2FibGVPUlNSYWRpb0J0bnMoZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25Qcm92aWRlcnMub3BlbnJvdXRlc2VydmljZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMuZW5hYmxlUHJvdmlkZXIoXCJvcGVucm91dGVzZXJ2aWNlXCIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBkaXNhYmxlT1JTUmFkaW9CdG5zKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIG9yc0RpcmVjdGlvbnNcbiAgICAgICAgLmFwcGVuZChcImxhYmVsXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJhaXItaGVhZGluZy1sYWJlbFwiKVxuICAgICAgICAuYXR0cihcImZvclwiLCBcInNob3ctb3JzLWN5Y2xpbmdcIilcbiAgICAgICAgLnRleHQoXCJPUEVOUk9VVEVTRVJWSUNFXCIpO1xuXG4gICAgdmFyIG9yc0N5Y2xpbmdPcHRpb25zID0gb3JzRGlyZWN0aW9ucy5hcHBlbmQoXCJkaXZcIik7XG4gICAgdmFyIG9yc0N5Y2xpbmdSZWd1bGFyID0gb3JzQ3ljbGluZ09wdGlvbnNcbiAgICAgICAgLmFwcGVuZChcImlucHV0XCIpXG4gICAgICAgIC5hdHRyKFwidHlwZVwiLCBcInJhZGlvXCIpXG4gICAgICAgIC5hdHRyKFwibmFtZVwiLCBcIm9yc1Byb2ZpbGVCaWN5Y2xlXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJvcnMtYmljeWNsZS1yZWd1bGFyXCIpXG4gICAgICAgIC5hdHRyKFwidmFsdWVcIiwgXCJjeWNsaW5nLXJlZ3VsYXJcIilcbiAgICAgICAgLnByb3BlcnR5KFwiY2hlY2tlZFwiLCB0cnVlKVxuICAgICAgICAucHJvcGVydHkoXCJkaXNhYmxlZFwiLCB0cnVlKVxuICAgICAgICAub24oXCJjaGFuZ2VcIiwgY2hhbmdlT1JTQ3ljbGluZ09wdGlvbik7XG5cbiAgICBvcnNDeWNsaW5nT3B0aW9uc1xuICAgICAgICAuYXBwZW5kKFwibGFiZWxcIilcbiAgICAgICAgLmF0dHIoXCJmb3JcIiwgXCJvcnMtYmljeWNsZS1yZWd1bGFyXCIpXG4gICAgICAgIC5odG1sKFwiTm9ybWFsXCIpO1xuXG4gICAgdmFyIG9yc0N5Y2xpbmdTYWZlID0gb3JzQ3ljbGluZ09wdGlvbnNcbiAgICAgICAgLmFwcGVuZChcImlucHV0XCIpXG4gICAgICAgIC5hdHRyKFwidHlwZVwiLCBcInJhZGlvXCIpXG4gICAgICAgIC5hdHRyKFwibmFtZVwiLCBcIm9yc1Byb2ZpbGVCaWN5Y2xlXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJvcnMtYmljeWNsZS1zYWZlXCIpXG4gICAgICAgIC5hdHRyKFwidmFsdWVcIiwgXCJjeWNsaW5nLXNhZmVcIilcbiAgICAgICAgLnByb3BlcnR5KFwiZGlzYWJsZWRcIiwgdHJ1ZSlcbiAgICAgICAgLm9uKFwiY2hhbmdlXCIsIGNoYW5nZU9SU0N5Y2xpbmdPcHRpb24pO1xuXG4gICAgb3JzQ3ljbGluZ09wdGlvbnNcbiAgICAgICAgLmFwcGVuZChcImxhYmVsXCIpXG4gICAgICAgIC5hdHRyKFwiZm9yXCIsIFwib3JzLWJpY3ljbGUtc2FmZVwiKVxuICAgICAgICAuaHRtbChcIlNhZmVzdFwiKTtcblxuICAgIHZhciBvcnNDeWNsaW5nVG91ciA9IG9yc0N5Y2xpbmdPcHRpb25zXG4gICAgICAgIC5hcHBlbmQoXCJpbnB1dFwiKVxuICAgICAgICAuYXR0cihcInR5cGVcIiwgXCJyYWRpb1wiKVxuICAgICAgICAuYXR0cihcIm5hbWVcIiwgXCJvcnNQcm9maWxlQmljeWNsZVwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwib3JzLWJpY3ljbGUtdG91clwiKVxuICAgICAgICAuYXR0cihcInZhbHVlXCIsIFwiY3ljbGluZy10b3VyXCIpXG4gICAgICAgIC5wcm9wZXJ0eShcImRpc2FibGVkXCIsIHRydWUpXG4gICAgICAgIC5vbihcImNoYW5nZVwiLCBjaGFuZ2VPUlNDeWNsaW5nT3B0aW9uKTtcblxuICAgIG9yc0N5Y2xpbmdPcHRpb25zXG4gICAgICAgIC5hcHBlbmQoXCJsYWJlbFwiKVxuICAgICAgICAuYXR0cihcImZvclwiLCBcIm9ycy1iaWN5Y2xlLXRvdXJcIilcbiAgICAgICAgLmh0bWwoXCJUb3VyaW5nIGJpa2VcIik7XG5cbiAgICB2YXIgb3JzQ3ljbGluZ01vdW50YWluID0gb3JzQ3ljbGluZ09wdGlvbnNcbiAgICAgICAgLmFwcGVuZChcImlucHV0XCIpXG4gICAgICAgIC5hdHRyKFwidHlwZVwiLCBcInJhZGlvXCIpXG4gICAgICAgIC5hdHRyKFwibmFtZVwiLCBcIm9yc1Byb2ZpbGVCaWN5Y2xlXCIpXG4gICAgICAgIC5hdHRyKFwiaWRcIiwgXCJvcnMtYmljeWNsZS1tb3VudGFpblwiKVxuICAgICAgICAuYXR0cihcInZhbHVlXCIsIFwiY3ljbGluZy1tb3VudGFpblwiKVxuICAgICAgICAucHJvcGVydHkoXCJkaXNhYmxlZFwiLCB0cnVlKVxuICAgICAgICAub24oXCJjaGFuZ2VcIiwgY2hhbmdlT1JTQ3ljbGluZ09wdGlvbik7XG5cbiAgICBvcnNDeWNsaW5nT3B0aW9uc1xuICAgICAgICAuYXBwZW5kKFwibGFiZWxcIilcbiAgICAgICAgLmF0dHIoXCJmb3JcIiwgXCJvcnMtYmljeWNsZS1tb3VudGFpblwiKVxuICAgICAgICAuaHRtbChcIk1vdW50YWluIGJpa2VcIik7XG5cbiAgICB2YXIgb3JzQ3ljbGluZ1JvYWQgPSBvcnNDeWNsaW5nT3B0aW9uc1xuICAgICAgICAuYXBwZW5kKFwiaW5wdXRcIilcbiAgICAgICAgLmF0dHIoXCJ0eXBlXCIsIFwicmFkaW9cIilcbiAgICAgICAgLmF0dHIoXCJuYW1lXCIsIFwib3JzUHJvZmlsZUJpY3ljbGVcIilcbiAgICAgICAgLmF0dHIoXCJpZFwiLCBcIm9ycy1iaWN5Y2xlLXJvYWRcIilcbiAgICAgICAgLmF0dHIoXCJ2YWx1ZVwiLCBcImN5Y2xpbmctcm9hZFwiKVxuICAgICAgICAucHJvcGVydHkoXCJkaXNhYmxlZFwiLCB0cnVlKVxuICAgICAgICAub24oXCJjaGFuZ2VcIiwgY2hhbmdlT1JTQ3ljbGluZ09wdGlvbik7XG5cbiAgICBvcnNDeWNsaW5nT3B0aW9uc1xuICAgICAgICAuYXBwZW5kKFwibGFiZWxcIilcbiAgICAgICAgLmF0dHIoXCJmb3JcIiwgXCJvcnMtYmljeWNsZS1yb2FkXCIpXG4gICAgICAgIC5odG1sKFwiUm9hZCBiaWtlXCIpO1xuXG4gICAgdmFyIG9yc0N5Y2xpbmdFbGVjdHJpYyA9IG9yc0N5Y2xpbmdPcHRpb25zXG4gICAgICAgIC5hcHBlbmQoXCJpbnB1dFwiKVxuICAgICAgICAuYXR0cihcInR5cGVcIiwgXCJyYWRpb1wiKVxuICAgICAgICAuYXR0cihcIm5hbWVcIiwgXCJvcnNQcm9maWxlQmljeWNsZVwiKVxuICAgICAgICAuYXR0cihcImlkXCIsIFwib3JzLWJpY3ljbGUtZWxlY3RyaWNcIilcbiAgICAgICAgLmF0dHIoXCJ2YWx1ZVwiLCBcImN5Y2xpbmctZWxlY3RyaWNcIilcbiAgICAgICAgLnByb3BlcnR5KFwiZGlzYWJsZWRcIiwgdHJ1ZSlcbiAgICAgICAgLm9uKFwiY2hhbmdlXCIsIGNoYW5nZU9SU0N5Y2xpbmdPcHRpb24pO1xuXG4gICAgb3JzQ3ljbGluZ09wdGlvbnNcbiAgICAgICAgLmFwcGVuZChcImxhYmVsXCIpXG4gICAgICAgIC5hdHRyKFwiZm9yXCIsIFwib3JzLWJpY3ljbGUtZWxlY3RyaWNcIilcbiAgICAgICAgLmh0bWwoXCJlLWJpa2VcIik7XG5cbiAgICBmdW5jdGlvbiBjaGFuZ2VPUlNDeWNsaW5nT3B0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRPcHRpb24gPSBkM1xuICAgICAgICAgICAgLnNlbGVjdChcImlucHV0W25hbWU9b3JzUHJvZmlsZUJpY3ljbGVdOmNoZWNrZWRcIilcbiAgICAgICAgICAgIC5hdHRyKFwidmFsdWVcIik7XG4gICAgICAgIGRpcmVjdGlvbnMucXVlcnkoe1xuICAgICAgICAgICAgcHJvdmlkZXI6IFwib3BlbnJvdXRlc2VydmljZVwiLFxuICAgICAgICAgICAgcHJvZmlsZTogc2VsZWN0ZWRPcHRpb25cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzYWJsZU9SU1JhZGlvQnRucyhpc19kaXNhYmxlZCkge1xuICAgICAgICBkMy5zZWxlY3RBbGwoXCJpbnB1dFtuYW1lPSdvcnNQcm9maWxlQmljeWNsZSddXCIpWzBdLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgci5kaXNhYmxlZCA9IGlzX2Rpc2FibGVkO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQod2F5cG9pbnQpIHtcbiAgICAgICAgaWYgKCF3YXlwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH0gZWxzZSBpZiAod2F5cG9pbnQucHJvcGVydGllcy5uYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gd2F5cG9pbnQucHJvcGVydGllcy5uYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKHdheXBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgcHJlY2lzaW9uID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICBNYXRoLmNlaWwoTWF0aC5sb2cobWFwLmdldFpvb20oKSkgLyBNYXRoLkxOMilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHdheXBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLnRvRml4ZWQocHJlY2lzaW9uKSArXG4gICAgICAgICAgICAgICAgXCIsIFwiICtcbiAgICAgICAgICAgICAgICB3YXlwb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc1sxXS50b0ZpeGVkKHByZWNpc2lvbilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gd2F5cG9pbnQucHJvcGVydGllcy5xdWVyeSB8fCBcIlwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlyZWN0aW9uc1xuICAgICAgICAub24oXCJvcmlnaW5cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgb3JpZ2luSW5wdXQucHJvcGVydHkoXCJ2YWx1ZVwiLCBmb3JtYXQoZS5vcmlnaW4pKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiZGVzdGluYXRpb25cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb25JbnB1dC5wcm9wZXJ0eShcInZhbHVlXCIsIGZvcm1hdChlLmRlc3RpbmF0aW9uKSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImNoZWNrbWFwYm94XCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNoZWNrYm94TWFwYm94LnByb3BlcnR5KFwiY2hlY2tlZFwiLCBmYWxzZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImNoZWNrZ29vZ2xlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNoZWNrYm94R29vZ2xlLnByb3BlcnR5KFwiY2hlY2tlZFwiLCBmYWxzZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImNoZWNrb3JzXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNoZWNrYm94T1JTLnByb3BlcnR5KFwiY2hlY2tlZFwiLCBmYWxzZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImxvYWRcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgb3JpZ2luSW5wdXQucHJvcGVydHkoXCJ2YWx1ZVwiLCBmb3JtYXQoZS5vcmlnaW4pKTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uSW5wdXQucHJvcGVydHkoXCJ2YWx1ZVwiLCBmb3JtYXQoZS5kZXN0aW5hdGlvbikpO1xuICAgICAgICB9KTtcblxuICAgIHJldHVybiBjb250cm9sO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZGVib3VuY2UgPSByZXF1aXJlKFwiZGVib3VuY2VcIik7XG5cbnZhciBMYXllciA9IEwuTGF5ZXJHcm91cC5leHRlbmQoe1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgcmVhZG9ubHk6IGZhbHNlXG4gICAgfSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRpcmVjdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb25zID0gZGlyZWN0aW9ucyB8fCBuZXcgTC5EaXJlY3Rpb25zKCk7XG4gICAgICAgIEwuTGF5ZXJHcm91cC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzKTtcblxuICAgICAgICB0aGlzLl9kcmFnID0gZGVib3VuY2UoTC5iaW5kKHRoaXMuX2RyYWcsIHRoaXMpLCAxMDApO1xuXG4gICAgICAgIHRoaXMub3JpZ2luTWFya2VyID0gTC5tYXJrZXIoWzAsIDBdLCB7XG4gICAgICAgICAgICBkcmFnZ2FibGU6ICF0aGlzLm9wdGlvbnMucmVhZG9ubHksXG4gICAgICAgICAgICBpY29uOiBMLm1hcGJveC5tYXJrZXIuaWNvbih7XG4gICAgICAgICAgICAgICAgXCJtYXJrZXItc2l6ZVwiOiBcIm1lZGl1bVwiLFxuICAgICAgICAgICAgICAgIFwibWFya2VyLWNvbG9yXCI6IFwiIzNCQjJEMFwiLFxuICAgICAgICAgICAgICAgIFwibWFya2VyLXN5bWJvbFwiOiBcImFcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSkub24oXCJkcmFnXCIsIHRoaXMuX2RyYWcsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25NYXJrZXIgPSBMLm1hcmtlcihbMCwgMF0sIHtcbiAgICAgICAgICAgIGRyYWdnYWJsZTogIXRoaXMub3B0aW9ucy5yZWFkb25seSxcbiAgICAgICAgICAgIGljb246IEwubWFwYm94Lm1hcmtlci5pY29uKHtcbiAgICAgICAgICAgICAgICBcIm1hcmtlci1zaXplXCI6IFwibWVkaXVtXCIsXG4gICAgICAgICAgICAgICAgXCJtYXJrZXItY29sb3JcIjogXCIjNDQ0XCIsXG4gICAgICAgICAgICAgICAgXCJtYXJrZXItc3ltYm9sXCI6IFwiYlwiXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KS5vbihcImRyYWdcIiwgdGhpcy5fZHJhZywgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5zdGVwTWFya2VyID0gTC5tYXJrZXIoWzAsIDBdLCB7XG4gICAgICAgICAgICBpY29uOiBMLmRpdkljb24oe1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTpcbiAgICAgICAgICAgICAgICAgICAgXCJtYXBib3gtbWFya2VyLWRyYWctaWNvbiBtYXBib3gtbWFya2VyLWRyYWctaWNvbi1zdGVwXCIsXG4gICAgICAgICAgICAgICAgaWNvblNpemU6IG5ldyBMLlBvaW50KDEyLCAxMilcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZHJhZ01hcmtlciA9IEwubWFya2VyKFswLCAwXSwge1xuICAgICAgICAgICAgZHJhZ2dhYmxlOiAhdGhpcy5vcHRpb25zLnJlYWRvbmx5LFxuICAgICAgICAgICAgaWNvbjogdGhpcy5fd2F5cG9pbnRJY29uKClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5kcmFnTWFya2VyXG4gICAgICAgICAgICAub24oXCJkcmFnc3RhcnRcIiwgdGhpcy5fZHJhZ1N0YXJ0LCB0aGlzKVxuICAgICAgICAgICAgLm9uKFwiZHJhZ1wiLCB0aGlzLl9kcmFnLCB0aGlzKVxuICAgICAgICAgICAgLm9uKFwiZHJhZ2VuZFwiLCB0aGlzLl9kcmFnRW5kLCB0aGlzKTtcblxuICAgICAgICB0aGlzLnJvdXRlTGF5ZXIgPSBMLm1hcGJveC5mZWF0dXJlTGF5ZXIoKTtcbiAgICAgICAgdGhpcy5yb3V0ZUhpZ2hsaWdodExheWVyID0gTC5tYXBib3guZmVhdHVyZUxheWVyKCk7XG4gICAgICAgIHRoaXMudHJhY2tMYXllciA9IEwubWFwYm94LmZlYXR1cmVMYXllcigpO1xuICAgIH0sXG5cbiAgICBvbkFkZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIEwuTGF5ZXJHcm91cC5wcm90b3R5cGUub25BZGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5yZWFkb25seSkge1xuICAgICAgICAgICAgdGhpcy5fbWFwXG4gICAgICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiwgdGhpcy5fY2xpY2ssIHRoaXMpXG4gICAgICAgICAgICAgICAgLm9uKFwibW91c2Vtb3ZlXCIsIHRoaXMuX21vdXNlbW92ZSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kaXJlY3Rpb25zXG4gICAgICAgICAgICAub24oXCJvcmlnaW5cIiwgdGhpcy5fb3JpZ2luLCB0aGlzKVxuICAgICAgICAgICAgLm9uKFwiZGVzdGluYXRpb25cIiwgdGhpcy5fZGVzdGluYXRpb24sIHRoaXMpXG4gICAgICAgICAgICAub24oXCJsb2FkXCIsIHRoaXMuX2xvYWQsIHRoaXMpXG4gICAgICAgICAgICAub24oXCJ1bmxvYWRcIiwgdGhpcy5fdW5sb2FkLCB0aGlzKVxuICAgICAgICAgICAgLm9uKFwic2VsZWN0Um91dGVcIiwgdGhpcy5fc2VsZWN0Um91dGUsIHRoaXMpXG4gICAgICAgICAgICAub24oXCJzZWxlY3RUcmFja1wiLCB0aGlzLl9zZWxlY3RUcmFjaywgdGhpcylcbiAgICAgICAgICAgIC5vbihcImhpZ2hsaWdodFJvdXRlXCIsIHRoaXMuX2hpZ2hsaWdodFJvdXRlLCB0aGlzKVxuICAgICAgICAgICAgLm9uKFwiaGlnaGxpZ2h0U3RlcFwiLCB0aGlzLl9oaWdobGlnaHRTdGVwLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgb25SZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb25zXG4gICAgICAgICAgICAub2ZmKFwib3JpZ2luXCIsIHRoaXMuX29yaWdpbiwgdGhpcylcbiAgICAgICAgICAgIC5vZmYoXCJkZXN0aW5hdGlvblwiLCB0aGlzLl9kZXN0aW5hdGlvbiwgdGhpcylcbiAgICAgICAgICAgIC5vZmYoXCJsb2FkXCIsIHRoaXMuX2xvYWQsIHRoaXMpXG4gICAgICAgICAgICAub2ZmKFwidW5sb2FkXCIsIHRoaXMuX3VubG9hZCwgdGhpcylcbiAgICAgICAgICAgIC5vZmYoXCJzZWxlY3RSb3V0ZVwiLCB0aGlzLl9zZWxlY3RSb3V0ZSwgdGhpcylcbiAgICAgICAgICAgIC5vZmYoXCJzZWxlY3RUcmFja1wiLCB0aGlzLl9zZWxlY3RUcmFjaywgdGhpcylcbiAgICAgICAgICAgIC5vZmYoXCJoaWdobGlnaHRSb3V0ZVwiLCB0aGlzLl9oaWdobGlnaHRSb3V0ZSwgdGhpcylcbiAgICAgICAgICAgIC5vZmYoXCJoaWdobGlnaHRTdGVwXCIsIHRoaXMuX2hpZ2hsaWdodFN0ZXAsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX21hcFxuICAgICAgICAgICAgLm9mZihcImNsaWNrXCIsIHRoaXMuX2NsaWNrLCB0aGlzKVxuICAgICAgICAgICAgLm9mZihcIm1vdXNlbW92ZVwiLCB0aGlzLl9tb3VzZW1vdmUsIHRoaXMpO1xuXG4gICAgICAgIEwuTGF5ZXJHcm91cC5wcm90b3R5cGUub25SZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgX2NsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGlyZWN0aW9ucy5nZXRPcmlnaW4oKSkge1xuICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9ucy5zZXRPcmlnaW4oZS5sYXRsbmcpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9kaXJlY3Rpb25zLmdldERlc3RpbmF0aW9uKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbnMuc2V0RGVzdGluYXRpb24oZS5sYXRsbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiAodGhpcy5fZGlyZWN0aW9ucy5xdWVyeWFibGUoKSkge1xuICAgICAgICAvL3RoaXMuX2RpcmVjdGlvbnMucXVlcnkoKTtcbiAgICAgICAgLy99XG4gICAgfSxcblxuICAgIF9tb3VzZW1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIXRoaXMucm91dGVMYXllciB8fFxuICAgICAgICAgICAgIXRoaXMuaGFzTGF5ZXIodGhpcy5yb3V0ZUxheWVyKSB8fFxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFdheXBvaW50ICE9PSB1bmRlZmluZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcCA9IHRoaXMuX3JvdXRlUG9seWxpbmUoKS5jbG9zZXN0TGF5ZXJQb2ludChlLmxheWVyUG9pbnQpO1xuXG4gICAgICAgIGlmICghcCB8fCBwLmRpc3RhbmNlID4gMTUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUxheWVyKHRoaXMuZHJhZ01hcmtlcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbSA9IHRoaXMuX21hcC5wcm9qZWN0KGUubGF0bG5nKSxcbiAgICAgICAgICAgIG8gPSB0aGlzLl9tYXAucHJvamVjdCh0aGlzLm9yaWdpbk1hcmtlci5nZXRMYXRMbmcoKSksXG4gICAgICAgICAgICBkID0gdGhpcy5fbWFwLnByb2plY3QodGhpcy5kZXN0aW5hdGlvbk1hcmtlci5nZXRMYXRMbmcoKSk7XG5cbiAgICAgICAgaWYgKG8uZGlzdGFuY2VUbyhtKSA8IDE1IHx8IGQuZGlzdGFuY2VUbyhtKSA8IDE1KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVMYXllcih0aGlzLmRyYWdNYXJrZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kcmFnTWFya2VyLnNldExhdExuZyh0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKHApKTtcbiAgICAgICAgdGhpcy5hZGRMYXllcih0aGlzLmRyYWdNYXJrZXIpO1xuICAgIH0sXG5cbiAgICBfb3JpZ2luOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLm9yaWdpbiAmJiBlLm9yaWdpbi5nZW9tZXRyeS5jb29yZGluYXRlcykge1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5NYXJrZXIuc2V0TGF0TG5nKFxuICAgICAgICAgICAgICAgIEwuR2VvSlNPTi5jb29yZHNUb0xhdExuZyhlLm9yaWdpbi5nZW9tZXRyeS5jb29yZGluYXRlcylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmFkZExheWVyKHRoaXMub3JpZ2luTWFya2VyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGF5ZXIodGhpcy5vcmlnaW5NYXJrZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9kZXN0aW5hdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5kZXN0aW5hdGlvbiAmJiBlLmRlc3RpbmF0aW9uLmdlb21ldHJ5LmNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uTWFya2VyLnNldExhdExuZyhcbiAgICAgICAgICAgICAgICBMLkdlb0pTT04uY29vcmRzVG9MYXRMbmcoZS5kZXN0aW5hdGlvbi5nZW9tZXRyeS5jb29yZGluYXRlcylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLmFkZExheWVyKHRoaXMuZGVzdGluYXRpb25NYXJrZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVMYXllcih0aGlzLmRlc3RpbmF0aW9uTWFya2VyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfbG9hZDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLl9vcmlnaW4oZSk7XG4gICAgICAgIHRoaXMuX2Rlc3RpbmF0aW9uKGUpO1xuICAgIH0sXG5cbiAgICBfdW5sb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMYXllcih0aGlzLnJvdXRlTGF5ZXIpO1xuICAgICAgICB0aGlzLnJlbW92ZUxheWVyKHRoaXMudHJhY2tMYXllcik7XG4gICAgfSxcblxuICAgIF9zZWxlY3RSb3V0ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLnJvdXRlTGF5ZXIuY2xlYXJMYXllcnMoKS5zZXRHZW9KU09OKGUucm91dGUpO1xuICAgICAgICB0aGlzLmFkZExheWVyKHRoaXMucm91dGVMYXllcik7XG4gICAgfSxcblxuICAgIF9zZWxlY3RUcmFjazogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLnRyYWNrTGF5ZXIuY2xlYXJMYXllcnMoKS5zZXRHZW9KU09OKGUudHJhY2spO1xuICAgICAgICB0aGlzLmFkZExheWVyKHRoaXMudHJhY2tMYXllcik7XG4gICAgICAgIHRoaXMucmVtb3ZlTGF5ZXIodGhpcy5yb3V0ZUxheWVyKTtcbiAgICB9LFxuXG4gICAgX2hpZ2hsaWdodFJvdXRlOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLnJvdXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJvdXRlSGlnaGxpZ2h0TGF5ZXIuY2xlYXJMYXllcnMoKS5zZXRHZW9KU09OKGUucm91dGUuZ2VvbWV0cnkpO1xuICAgICAgICAgICAgdGhpcy5hZGRMYXllcih0aGlzLnJvdXRlSGlnaGxpZ2h0TGF5ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVMYXllcih0aGlzLnJvdXRlSGlnaGxpZ2h0TGF5ZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9oaWdobGlnaHRTdGVwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLnN0ZXAgJiYgZS5zdGVwLmxvYykge1xuICAgICAgICAgICAgdGhpcy5zdGVwTWFya2VyLnNldExhdExuZyhMLkdlb0pTT04uY29vcmRzVG9MYXRMbmcoZS5zdGVwLmxvYykpO1xuICAgICAgICAgICAgdGhpcy5hZGRMYXllcih0aGlzLnN0ZXBNYXJrZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVMYXllcih0aGlzLnN0ZXBNYXJrZXIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9yb3V0ZVBvbHlsaW5lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm91dGVMYXllci5nZXRMYXllcnMoKVswXTtcbiAgICB9LFxuXG4gICAgX2ZpbmROZWFyZXN0Um91dGVTZWdtZW50OiBmdW5jdGlvbihsYXRMbmcpIHtcbiAgICAgICAgdmFyIG1pbiA9IEluZmluaXR5LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBwID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRMbmcpLFxuICAgICAgICAgICAgcG9zaXRpb25zID0gdGhpcy5fcm91dGVQb2x5bGluZSgpLl9vcmlnaW5hbFBvaW50cztcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGQgPSBMLkxpbmVVdGlsLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChcbiAgICAgICAgICAgICAgICBwLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tpIC0gMV0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb25zW2ldLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoZCA8IG1pbikge1xuICAgICAgICAgICAgICAgIG1pbiA9IGQ7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICBfd2F5cG9pbnRJY29uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEwuZGl2SWNvbih7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwibWFwYm94LW1hcmtlci1kcmFnLWljb25cIixcbiAgICAgICAgICAgIGljb25TaXplOiBuZXcgTC5Qb2ludCgxMiwgMTIpXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRpcmVjdGlvbnMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IExheWVyKGRpcmVjdGlvbnMsIG9wdGlvbnMpO1xufTtcbiIsIi8qIEBmbG93ICovXG52YXIgZG9tID0gZG9jdW1lbnQ7IC8vIHRoaXMgdG8gY2xhaW0gdGhhdCB3ZSB1c2UgdGhlIGRvbSBhcGksIG5vdCByZXByZXNlbnRhdGl2ZSBvZiB0aGUgcGFnZSBkb2N1bWVudFxuXG52YXIgUGFnaW5nQ29udHJvbCA9IGZ1bmN0aW9uKFxuICAgIGVsZW1lbnQgLyo6IEVsZW1lbnQgKi8gLFxuICAgIG9wdGlvbnMgLyo6ID9PYmplY3QgKi9cbikge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLmRpc3BsYXllZCA9IG9wdGlvbnMuZGlzcGxheWVkIHx8IDEwO1xuICAgIG9wdGlvbnMudG90YWwgPSBvcHRpb25zLnRvdGFsIHx8IDEwO1xuXG4gICAgdGhpcy51cGRhdGUob3B0aW9ucyk7XG4gICAgdGhpcy5zZWxlY3RlZCA9IDE7XG5cbiAgICAvLyBzZXQgZW1wdHkgZXZlbnQgaGFuZGxlcnNcbiAgICB0aGlzLm9uU2VsZWN0ZWQoZnVuY3Rpb24oKSB7fSk7XG59O1xuXG5QYWdpbmdDb250cm9sLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoXG4gICAgICAgIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdhW3JlbD1wYWdlXScpLFxuICAgICAgICBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgKTtcbn07XG5cbnZhciBjYWxjUmFuZ2UgPSBmdW5jdGlvbihmb2N1cywgZGlzcGxheWVkLCB0b3RhbCkge1xuICAgIHZhciBoYWxmID0gTWF0aC5mbG9vcihkaXNwbGF5ZWQgLyAyKTtcbiAgICB2YXIgcGFnZU1heCA9IE1hdGgubWluKHRvdGFsLCBkaXNwbGF5ZWQpO1xuICAgIGlmIChmb2N1cyAtIGhhbGYgPCAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogMSxcbiAgICAgICAgICAgIGVuZDogcGFnZU1heFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoZm9jdXMgKyBoYWxmID4gdG90YWwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiB0b3RhbCAtIGRpc3BsYXllZCArIDEsXG4gICAgICAgICAgICBlbmQ6IHRvdGFsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBmb2N1cyAtIGhhbGYsXG4gICAgICAgIGVuZDogZm9jdXMgKyBoYWxmXG4gICAgfTtcbn07XG5cblBhZ2luZ0NvbnRyb2wucHJvdG90eXBlLm9uU2VsZWN0ZWQgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkaXNwbGF5ZWQgPSB0aGlzLm9wdGlvbnMuZGlzcGxheWVkO1xuXG4gICAgdGhpcy5vblNlbGVjdGVkSGFuZGxlciA9IGZ1bmN0aW9uKHBhZ2VObykge1xuICAgICAgICBzZWxmLmNsZWFyKCk7XG4gICAgICAgIHZhciByYW5nZSA9IGNhbGNSYW5nZShwYWdlTm8sIGRpc3BsYXllZCwgc2VsZi5vcHRpb25zLnRvdGFsKTtcbiAgICAgICAgc2VsZi5yZW5kZXJQYWdlcyhyYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBwYWdlTm8pO1xuICAgICAgICByZXR1cm4gaGFuZGxlcihwYWdlTm8pO1xuICAgIH07XG59O1xuXG5QYWdpbmdDb250cm9sLnByb3RvdHlwZS5yZW5kZXJQYWdlcyA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHNlbGVjdGVkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBnZW5IYW5kbGVyID0gZnVuY3Rpb24ocGFnZU5vKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYub25TZWxlY3RlZEhhbmRsZXIocGFnZU5vKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgIHZhciBwYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBwYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZ2VuSGFuZGxlcihpKSk7XG4gICAgICAgIHBhZ2UucmVsID0gJ3BhZ2UnO1xuICAgICAgICBwYWdlLmhyZWYgPSAnIyc7XG4gICAgICAgIHBhZ2UudGV4dENvbnRlbnQgPSBpO1xuICAgICAgICBpZiAoaSA9PT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHBhZ2UuY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZChwYWdlKTtcbiAgICB9XG59O1xuXG5QYWdpbmdDb250cm9sLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5yZW5kZXJQYWdlcygxLCBNYXRoLm1pbihvcHRpb25zLnRvdGFsLCBvcHRpb25zLmRpc3BsYXllZCksIDEpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYWdpbmdDb250cm9sO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkMyA9IHJlcXVpcmUoXCIuLi9saWIvZDNcIiksXG4gICAgZm9ybWF0ID0gcmVxdWlyZShcIi4vZm9ybWF0XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGlyZWN0aW9ucykge1xuICAgIHZhciBjb250cm9sID0ge30sXG4gICAgICAgIG1hcCxcbiAgICAgICAgc2VsZWN0aW9uID0gMDtcblxuICAgIGNvbnRyb2wuYWRkVG8gPSBmdW5jdGlvbihfKSB7XG4gICAgICAgIG1hcCA9IF87XG4gICAgICAgIHJldHVybiBjb250cm9sO1xuICAgIH07XG5cbiAgICBjb250YWluZXIgPSBkM1xuICAgICAgICAuc2VsZWN0KEwuRG9tVXRpbC5nZXQoY29udGFpbmVyKSlcbiAgICAgICAgLmNsYXNzZWQoXCJtYXBib3gtZGlyZWN0aW9ucy1yb3V0ZXNcIiwgdHJ1ZSk7XG5cbiAgICBkaXJlY3Rpb25zLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnRhaW5lci5odG1sKFwiXCIpO1xuICAgIH0pO1xuXG4gICAgZGlyZWN0aW9ucy5vbihcImxvYWRcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBjb250YWluZXIuaHRtbChcIlwiKTtcblxuICAgICAgICB2YXIgcm91dGVzID0gY29udGFpbmVyXG4gICAgICAgICAgICAuYXBwZW5kKFwidWxcIilcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCJsaVwiKVxuICAgICAgICAgICAgLmRhdGEoZS5yb3V0ZXMpXG4gICAgICAgICAgICAuZW50ZXIoKVxuICAgICAgICAgICAgLmFwcGVuZChcImxpXCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibWFwYm94LWRpcmVjdGlvbnMtcm91dGVcIik7XG5cbiAgICAgICAgcm91dGVzXG4gICAgICAgICAgICAuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibWFwYm94LWRpcmVjdGlvbnMtcm91dGUtaGVhZGluZ1wiKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24ocm91dGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSb3V0ZSBcIiArIChlLnJvdXRlcy5pbmRleE9mKHJvdXRlKSArIDEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgcm91dGVzXG4gICAgICAgICAgICAuYXBwZW5kKFwiZGl2XCIpXG4gICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibWFwYm94LWRpcmVjdGlvbnMtcm91dGUtc3VtbWFyeVwiKVxuICAgICAgICAgICAgLnRleHQoZnVuY3Rpb24ocm91dGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm91dGUuc3VtbWFyeTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJvdXRlc1xuICAgICAgICAgICAgLmFwcGVuZChcImRpdlwiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcIm1hcGJveC1kaXJlY3Rpb25zLXJvdXRlLWRldGFpbHNcIilcbiAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0W2RpcmVjdGlvbnMub3B0aW9ucy51bml0c10ocm91dGUuZGlzdGFuY2UpICtcbiAgICAgICAgICAgICAgICAgICAgXCIsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0LmR1cmF0aW9uKHJvdXRlLmR1cmF0aW9uKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICByb3V0ZXMub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24ocm91dGUpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbnMuaGlnaGxpZ2h0Um91dGUocm91dGUpO1xuICAgICAgICB9KTtcblxuICAgICAgICByb3V0ZXMub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbnMuaGlnaGxpZ2h0Um91dGUobnVsbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJvdXRlcy5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKHJvdXRlKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb25zLnNlbGVjdFJvdXRlKHJvdXRlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGlyZWN0aW9ucy5zZWxlY3RSb3V0ZShlLnJvdXRlcyk7XG4gICAgfSk7XG5cbiAgICBkaXJlY3Rpb25zLm9uKFwic2VsZWN0Um91dGVcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBjb250YWluZXJcbiAgICAgICAgICAgIC5zZWxlY3RBbGwoXCIubWFwYm94LWRpcmVjdGlvbnMtcm91dGVcIilcbiAgICAgICAgICAgIC5jbGFzc2VkKFwibWFwYm94LWRpcmVjdGlvbnMtcm91dGUtYWN0aXZlXCIsIGZ1bmN0aW9uKHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdXRlID09PSBlLnJvdXRlO1xuICAgICAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29udHJvbDtcbn07XG4iLCIvKiBAZmxvdyAqL1xuXG52YXIgcmVuZGVyUm93ID0gZnVuY3Rpb24oY29udGFpbmVyLCBkYXRhKSB7XG4gICAgdmFyIHJvdyA9IGNvbnRhaW5lci5pbnNlcnRSb3coKTtcbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIHZhciBjZWxsID0gcm93Lmluc2VydENlbGwoKTtcbiAgICAgICAgY2VsbC50ZXh0Q29udGVudCA9IHN0cjtcbiAgICB9KTtcbiAgICByZXR1cm4gcm93O1xufTtcblxudmFyIHJlbmRlckhlYWRlciA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgZGF0YSkge1xuICAgIHZhciByb3cgPSBjb250YWluZXIuaW5zZXJ0Um93KCk7XG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHN0cikge1xuICAgICAgICB2YXIgdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpO1xuICAgICAgICB0aC5pbm5lckhUTUwgPSBzdHI7XG4gICAgICAgIHJvdy5hcHBlbmRDaGlsZCh0aCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJvdztcbn07XG5cbnZhciBUYWJsZUNvbnRyb2wgPSBmdW5jdGlvbihcbiAgICBlbGVtZW50IC8qOiBPYmplY3QgKi8sIC8qIFRhYmxlRWxlbWVudCAqL1xuICAgIGhlYWRlcnMgLyo6IFtzdHJpbmddICovLFxuICAgIG1vZGVsIC8qOiA/W1tzdHJpbmddXSAqL1xuKSB7XG4gICAgcmVuZGVySGVhZGVyKGVsZW1lbnQuY3JlYXRlVEhlYWQoKSwgaGVhZGVycyk7XG4gICAgdGhpcy50Ym9keSA9IGVsZW1lbnQuY3JlYXRlVEJvZHkoKTtcbiAgICB0aGlzLmJpbmQobW9kZWwgfHwgW10pO1xufTtcblxuVGFibGVDb250cm9sLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHdoaWxlICh0aGlzLnRib2R5Lmhhc0NoaWxkTm9kZXMoKSkgeyAgIFxuICAgICAgICB0aGlzLnRib2R5LnJlbW92ZUNoaWxkKHRoaXMudGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgfVxufTtcblxuVGFibGVDb250cm9sLnByb3RvdHlwZS5vblNlbGVjdGVkID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICAgIHRoaXMub25TZWxlY3RlZEhhbmRsZXIgPSBoYW5kbGVyO1xufTtcblxuVGFibGVDb250cm9sLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgLy8gZGVhbCB3aXRoIGNsb3N1cmVcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgbW9kZWwuZm9yRWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciByb3cgPSByZW5kZXJSb3coc2VsZi50Ym9keSwgZGF0YSk7XG4gICAgICAgIHJvdy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHNlbGYub25TZWxlY3RlZEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9uU2VsZWN0ZWRIYW5kbGVyKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVGFibGVDb250cm9sO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0YWJsZUNvbnRyb2wgPSByZXF1aXJlKFwiLi90YWJsZV9jb250cm9sLmpzXCIpLFxuICAgIHBhZ2luZ0NvbnRyb2wgPSByZXF1aXJlKFwiLi9wYWdpbmdfY29udHJvbC5qc1wiKSxcbiAgICBnZXRSZXF1ZXN0ID0gcmVxdWlyZShcIi4vZ2V0X3JlcXVlc3QuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29udGFpbmVyLCBkaXJlY3Rpb25zKSB7XG4gICAgdmFyIGNvbnRyb2wgPSB7fSxcbiAgICAgICAgbWFwO1xuICAgIHZhciBvcmlnQ2hhbmdlID0gZmFsc2UsXG4gICAgICAgIGRlc3RDaGFuZ2UgPSBmYWxzZTtcbiAgICB2YXIgVFJBQ0tJTkZPX0FQSV9VUkwgPSBcImh0dHBzOi8vbHVsaXUubWUvdHJhY2tzL2FwaS92MS90cmFja2luZm9cIjtcbiAgICB2YXIgVFJBQ0tfQVBJX1VSTCA9IFwiaHR0cHM6Ly9sdWxpdS5tZS90cmFja3MvYXBpL3YxL3RyYWNrc1wiO1xuXG4gICAgY29udHJvbC5hZGRUbyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgbWFwID0gXztcbiAgICAgICAgcmV0dXJuIGNvbnRyb2w7XG4gICAgfTtcblxuICAgIC8vIGdldCBwYWdlIDEgb2YgdHJhY2tpbmZvIGFzIGluaXQgZGF0YSBmb3IgdGhlIHRhYmxlXG4gICAgLy8gV2ViIGJyb3dzZXIgY29tcGF0aWJpbGl0eTpcbiAgICAvLyBmb3IgSUU3KywgRmlyZWZveCwgQ2hyb21lLCBPcGVyYSwgU2FmYXJpXG4gICAgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29udGFpbmVyKTtcbiAgICBjb250YWluZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKFxuICAgICAgICBcImFmdGVyYmVnaW5cIixcbiAgICAgICAgJzx0YWJsZSBpZD1cInRyYWNrcy10YWJsZVwiIGNsYXNzPVwicHJvc2UgYWlyLXRyYWNrc1wiPjwvdGFibGU+J1xuICAgICk7XG4gICAgY29udGFpbmVyLmluc2VydEFkamFjZW50SFRNTChcbiAgICAgICAgXCJiZWZvcmVlbmRcIixcbiAgICAgICAgJzxkaXYgaWQ9XCJwYWdpbmdcIiBkYXRhLWNvbnRyb2w9XCJwYWdpbmdcIj48L2Rpdj4nXG4gICAgKTtcblxuICAgIHZhciB0cmFja2luZm9LZXlzID0gW1xuICAgICAgICAgICAgXCJJRFwiLFxuICAgICAgICAgICAgXCJTZWdtZW50c1wiLFxuICAgICAgICAgICAgXCIyRCBsZW5ndGhcIixcbiAgICAgICAgICAgIFwiM0QgbGVuZ3RoXCIsXG4gICAgICAgICAgICBcIk1vdmluZyB0aW1lXCIsXG4gICAgICAgICAgICBcIlN0b3BwZWQgdGltZVwiLFxuICAgICAgICAgICAgXCJNYXggc3BlZWRcIixcbiAgICAgICAgICAgIFwiVXBoaWxsXCIsXG4gICAgICAgICAgICBcIkRvd25oaWxsXCIsXG4gICAgICAgICAgICBcIlN0YXJ0ZWQgYXRcIixcbiAgICAgICAgICAgIFwiRW5kZWQgYXRcIixcbiAgICAgICAgICAgIFwiUG9pbnRzXCIsXG4gICAgICAgICAgICBcIlN0YXJ0IGxvblwiLFxuICAgICAgICAgICAgXCJTdGFydCBsYXRcIixcbiAgICAgICAgICAgIFwiRW5kIGxvblwiLFxuICAgICAgICAgICAgXCJFbmQgbGF0XCJcbiAgICAgICAgXSxcbiAgICAgICAgdmFsdWVzID0gW107XG4gICAgdmFyIHBhZ2UgPSAxLFxuICAgICAgICB0b3RhbFBhZ2VzID0gMSxcbiAgICAgICAgbnVtUmVzdWx0cyA9IDE7XG4gICAgdmFyIHRjID0gbmV3IHRhYmxlQ29udHJvbChcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0cmFja3MtdGFibGVcIiksXG4gICAgICAgIHRyYWNraW5mb0tleXMsXG4gICAgICAgIHZhbHVlc1xuICAgICk7XG4gICAgdmFyIHBnID0gbmV3IHBhZ2luZ0NvbnRyb2woZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwYWdpbmdcIiksIHtcbiAgICAgICAgZGlzcGxheWVkOiAwLFxuICAgICAgICB0b3RhbDogMFxuICAgIH0pO1xuXG4gICAgdmFyIHRyYWNraW5mb1hociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHRyYWNraW5mb1hoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRyYWNraW5mb1hoci5yZWFkeVN0YXRlID09PSA0ICYmIHRyYWNraW5mb1hoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgdmFyIHRyYWNraW5mb0RhdGEgPSBKU09OLnBhcnNlKHRyYWNraW5mb1hoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgdG90YWxQYWdlcyA9IHRyYWNraW5mb0RhdGEudG90YWxfcGFnZXM7XG4gICAgICAgICAgICBwYWdlID0gdHJhY2tpbmZvRGF0YS5wYWdlO1xuICAgICAgICAgICAgbnVtUmVzdWx0cyA9IHRyYWNraW5mb0RhdGEubnVtX3Jlc3VsdHM7XG4gICAgICAgICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIHRyYWNraW5mb0RhdGEub2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gdHJhY2tpbmZvS2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocm93KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGMuYmluZCh2YWx1ZXMpO1xuICAgICAgICAgICAgcGcudXBkYXRlKHsgZGlzcGxheWVkOiAxMCwgdG90YWw6IHRvdGFsUGFnZXMgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRyYWNraW5mb1hoci5vcGVuKFwiR0VUXCIsIFRSQUNLSU5GT19BUElfVVJMLCB0cnVlKTtcbiAgICB0cmFja2luZm9YaHIuc2VuZCgpO1xuXG4gICAgdGMub25TZWxlY3RlZChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBzdGFydFBvcyA9IEwuR2VvSlNPTi5jb29yZHNUb0xhdExuZyhbZGF0YVsxMl0sIGRhdGFbMTNdXSk7XG4gICAgICAgIHZhciBlbmRQb3MgPSBMLkdlb0pTT04uY29vcmRzVG9MYXRMbmcoW2RhdGFbMTRdLCBkYXRhWzE1XV0pO1xuICAgICAgICBkaXJlY3Rpb25zLnNldE9yaWdpbihzdGFydFBvcyk7XG4gICAgICAgIGRpcmVjdGlvbnMuc2V0RGVzdGluYXRpb24oZW5kUG9zKTtcbiAgICAgICAgdmFyIHNvdXRoV2VzdCA9IEwubGF0TG5nKFxuICAgICAgICAgICAgICAgIE1hdGgubWluKHN0YXJ0UG9zLmxhdCwgZW5kUG9zLmxhdCksXG4gICAgICAgICAgICAgICAgTWF0aC5taW4oc3RhcnRQb3MubG5nLCBlbmRQb3MubG5nKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG5vcnRoRWFzdCA9IEwubGF0TG5nKFxuICAgICAgICAgICAgICAgIE1hdGgubWF4KHN0YXJ0UG9zLmxhdCwgZW5kUG9zLmxhdCksXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgoc3RhcnRQb3MubG5nLCBlbmRQb3MubG5nKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKHNvdXRoV2VzdCwgbm9ydGhFYXN0KTtcbiAgICAgICAgbWFwLmZpdEJvdW5kcyhib3VuZHMpO1xuICAgICAgICAvLyBXZWIgYnJvd3NlciBjb21wYXRpYmlsaXR5OlxuICAgICAgICAvLyBJRTcrLCBGaXJlZm94LCBDaHJvbWUsIE9wZXJhLCBTYWZhcmlcbiAgICAgICAgdmFyIHRyYWNrWGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHRyYWNrWGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRyYWNrWGhyLnJlYWR5U3RhdGUgPT09IDQgJiYgdHJhY2tYaHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2tEYXRhID0gSlNPTi5wYXJzZSh0cmFja1hoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMuc2VsZWN0VHJhY2sodHJhY2tEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdHJhY2tYaHIub3BlbihcIkdFVFwiLCBUUkFDS19BUElfVVJMICsgXCIvXCIgKyBkYXRhWzBdLCB0cnVlKTtcbiAgICAgICAgdHJhY2tYaHIuc2VuZCgpO1xuICAgIH0pO1xuXG4gICAgcGcub25TZWxlY3RlZChmdW5jdGlvbihwYWdlTm8pIHtcbiAgICAgICAgdmFyIHBhZ2VkVHJhY2tpbmZvWGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHBhZ2VkVHJhY2tpbmZvWGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHBhZ2VkVHJhY2tpbmZvWGhyLnJlYWR5U3RhdGUgPT09IDQgJiZcbiAgICAgICAgICAgICAgICBwYWdlZFRyYWNraW5mb1hoci5zdGF0dXMgPT09IDIwMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWNraW5mb0RhdGEgPSBKU09OLnBhcnNlKHBhZ2VkVHJhY2tpbmZvWGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyAzIHZhcmlhYmxlcyBjYW4gYmUgYXF1aXJlZCBmcm9tIHRoZSByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAvLyBidXQgdXNlbGVzcyBmb3IgdGhlIG1vbWVudFxuICAgICAgICAgICAgICAgIC8vdG90YWxQYWdlcyA9IHRyYWNraW5mb0RhdGEudG90YWxfcGFnZXM7XG4gICAgICAgICAgICAgICAgLy9wYWdlID0gdHJhY2tpbmZvRGF0YS5wYWdlO1xuICAgICAgICAgICAgICAgIC8vbnVtUmVzdWx0cyA9IHRyYWNraW5mb0RhdGEubnVtX3Jlc3VsdHM7XG4gICAgICAgICAgICAgICAgdmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgdHJhY2tpbmZvRGF0YS5vYmplY3RzLmZvckVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gdHJhY2tpbmZvS2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocm93KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0Yy5iaW5kKHZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHBhZ2VkVHJhY2tpbmZvWGhyLm9wZW4oXG4gICAgICAgICAgICBcIkdFVFwiLFxuICAgICAgICAgICAgVFJBQ0tJTkZPX0FQSV9VUkwgKyBcIj9wYWdlPVwiICsgcGFnZU5vLFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgICBwYWdlZFRyYWNraW5mb1hoci5zZW5kKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29udHJvbDtcbn07XG4iXX0=
;